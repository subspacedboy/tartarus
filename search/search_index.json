{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tartarus Smart Lock V2 Guides","text":"<p>Collection of guides for the Tartarus lock ecosystem.</p> <p>Go to the full Github repo.</p> <p>The Build Guide.</p>"},{"location":"architecture/","title":"Architecture Notes: How It All Works","text":"<p>This doc is a continuous work in progress.</p> <p>This serves as the rough architecture guide for how the whole thing works if you're curious.</p> <p>There's essentially three components: the lock, the website Tartarus, and the coordinator(API).</p> <p>The \"center\" of the system is the Coordinator. The locks need somewhere to send and receive updates, process commands etc. When they startup they check their local configuration and go through these steps:</p>"},{"location":"architecture/#cryptography","title":"Cryptography","text":"<p>Almost every entity in the system has a public and private keypair.</p> <p>Going into the details of a asymmetric cryptography is way beyond the scope of this doc. That being said:</p> <ul> <li>All keys use curve <code>secp256r1</code>.</li> <li>All public keys are represented in compressed form.</li> <li>All hashes are calculated with <code>sha256</code>.</li> <li>All signatures are to be in <code>raw</code> format, not <code>DER</code>.</li> <li>All symmetric cryptography is <code>aes-256-gcm</code>.</li> <li>All password that need to be verified are stored with <code>Scrypt</code> and params: 16384, 8, 1, 32.</li> <li>Where <code>HKDF</code> is used, we populate the info field with the task at hand.</li> <li>All <code>ByteArrays</code> are encoded with Base64 unless they are meant to be in a URL in which case we use URL-safe Base64.</li> <li>Online keys (<code>SafetyKey</code>) are stored as PKCS8 since they aren't transmitted.</li> </ul>"},{"location":"architecture/#signedmessage","title":"<code>SignedMessage</code>","text":"<p>All the commands and contracts are implemented as <code>SignedMessage</code>. A <code>SignedMessage</code> is a flatbuffer with a signed payload. So when you make a contract you generate the entire <code>Contract</code> flatbuffer, calculate a hash of the whole table, sign that, and then attach the signature to the outer-wrapper of the <code>SignedMessage</code>.</p> <p>Every entity that receives or forwards a <code>SignedMessage</code> will check the signature and reject the message if it fails to pass.</p>"},{"location":"architecture/#commands-counters-serial-numbers","title":"Commands, Counters &amp; Serial Numbers","text":"<p>All the commands after a <code>Contract</code> is accepted are to include a counter value. In order for a <code>SignedMessage</code> to be valid the counter value in the message has to be greater than or equal to the current counter in the lock. This is designed to prevent message replay (Someone trying to use an unlock code twice).</p> <p>All commands also have to include both their own unique serial number and the serial number of the contract they are issued under. If the contract serial number in a message doesn't match the current contract it will be rejected. This prevents one person's messages from being used on a different lock.</p>"},{"location":"architecture/#hashing","title":"Hashing","text":"<p>The hash of a flatbuffer has to also include the vtable of the message. Because the format essentially uses \"pointers\" in the format, all of those pointers also have to be covered- and those are the vtable. You'll see code like this almost anywhere a signature is needed:</p> <pre><code>builder.Finish(contract_offset)\nbytes = builder.Output()\n\nstart = bytes[0]\ncontract_start = bytes[start]\nvtable_start = start - contract_start\nhash = hashlib.sha256(bytes[vtable_start:]).digest()\nsignature = signer.sign(hash)contract_start = bytes[start]\nvtable_start = start - contract_start\nhash = hashlib.sha256(bytes[vtable_start:]).digest()\nsignature = signer.sign(hash)\n</code></pre>"},{"location":"architecture/#signature-format","title":"Signature Format","text":"<p>Signatures need to be raw r + s values, not <code>DER</code> encoded. This was an early design decision to minimize the size of <code>SignedMessage</code> tables so they would help fit inside scannable QR code blocks. The downside is most verification libraries like BouncyCastle want signatures in <code>DER</code> format so you'll need to convert them around.</p>"},{"location":"architecture/#signedevent","title":"<code>SignedEvent</code>","text":"<p>The lock will generate signed events for both the coordinator and any bots that are listed on a contract. They are similar in structure to <code>SignedMessage</code>.</p> <p>The events in the contract lifecycle are:</p> <ul> <li><code>Accept</code> - This event is emitted after the contract has been confirmed in the hardware.</li> <li><code>Lock</code> - The lock was locked via command from the coordinator.</li> <li><code>Unlock</code> - The lock was unlocked via command.</li> <li><code>LocalLock</code> - The lock button on the face of the lock was used. Only emits if temporary unlocking is allowed.</li> <li><code>LocalUnlock</code> - The unlock button on the face of the lock was used. Only emits if temporary unlocking is allowed.</li> <li><code>Release</code> - The contract was released and confirmed in hardware.</li> <li><code>Abort</code> - The contract was aborted via a <code>SafetyKey</code>.</li> </ul>"},{"location":"architecture/#contract-structure","title":"Contract structure","text":"<p>Contracts are pretty straight forward:</p> <pre><code>table Contract {\n  serial_number: ushort;\n  public_key: [ubyte];\n  bots: [Bot];\n  terms: string;\n  // If true, subject can freely cycle the lock.\n  is_temporary_unlock_allowed: bool;\n}\n</code></pre> <p>Notes:</p> <ul> <li>The serial number is randomly generated by the author.</li> <li>The <code>public_key</code> is the author's public key. All future commands will need to be signed by this key.</li> <li>The <code>bots</code> vector identifies which bots are allowed to participate in this contract.</li> <li>The <code>terms</code> string is just an unstructured string. It can include whatever you want. None of the core bits of the system will try and interpret this field.</li> <li>Lastly, should temporary unlocks be allowed. If this is true the buttons on the lock face will work, otherwise they won't.</li> </ul> <p>In the original design it was </p>"},{"location":"architecture/#bots-permissions","title":"Bots &amp; Permissions","text":"<p>Only bots listed on the contract body will be able to receive events. Events come directly from the lock, not the coordinator.</p> <p>Additionally, bots have four possible permission settings:</p> <ul> <li><code>receive_events</code> - Whether or not <code>SignedEvent</code> messages will be generated at their appropriate point in the lifecycle. If this is false no events will be sent to the bot.</li> <li><code>can_unlock</code> - If this is true the bot can sign an <code>UnlockCommand</code> and it will be accepted.</li> <li><code>can_lock</code> - Same as unlock but for lock.</li> <li><code>can_release</code> - If this is true the bot can end the contract.</li> </ul>"},{"location":"architecture/#lock-startup","title":"Lock Startup","text":"<p>What happens on lock startup.</p> <ul> <li>Send <code>StartedUpdate</code> from the Contract flatbuffers. If the coordinator has never heard from this lock before it will create a new <code>LockSession</code>. It also includes the public key material from the lock, whether it started with a contract, and what the current lock state is.</li> <li>Receive a <code>CoordinatorConfiguration</code> message potentially updating the lock's local configuration. Can also be used to set/toggle experimental features in the firmware.</li> <li>Sends a <code>GetLatestFirmwareRequest</code> that will us what the latest available version via OTA (\"Over the air\") is.</li> <li>Receive a <code>FirmwareChallengeRequest</code>. If you have an \"official\" build of the firmware it will have a key injected that can prove it's an official firmware. This is pretty much just ceremonial.</li> </ul> <p>From there it will publish a <code>PeriodicUpdate</code> once a minute indefinitely.</p>"},{"location":"architecture/#terms","title":"Terms","text":""},{"location":"architecture/#locksession","title":"<code>LockSession</code>","text":"<p>A <code>LockSession</code> uniquely defines a particular Tartarus lock.</p>"},{"location":"architecture/#lockusersession","title":"<code>LockUserSession</code>","text":"<p>This is an owner of a Tartarus lock logged into the website. You can simultaneously have a <code>LockUserSession</code> and an <code>AuthorSession</code>.</p>"},{"location":"architecture/#authorsession","title":"<code>AuthorSession</code>","text":"<p>This is someone logged into the website with a keypair image they generated and is authoring/managing contracts. You can simultaneously have a <code>LockUserSession</code> and an <code>AuthorSession</code>.</p>"},{"location":"architecture/#adminsession","title":"<code>AdminSession</code>","text":"<p>Admin users that have special, magical powers.</p>"},{"location":"architecture/#safetykey","title":"<code>SafetyKey</code>","text":"<p>A set of reserved online keys that can sign <code>Abort</code> messages. Only <code>AdminSession</code> users can use <code>SafetyKey</code>s. </p>"},{"location":"building_the_lock/","title":"Building the Lock","text":""},{"location":"building_the_lock/#bill-of-materials","title":"Bill of Materials","text":"<p>In order to build the lock you will need:</p>"},{"location":"building_the_lock/#mandatory-parts","title":"Mandatory parts","text":"<ul> <li>Adafruit ESP32-S3 Reverse TFT Feather - 4MB Flash, 2MB PSRAM, STEMMA QT. If you want an \"official\" build + badge on the coordinator, you'll need to order one from subjugated.club. Homebrew versions are totally welcome and don't limit your features.</li> <li>STEMMA QT / Qwiic JST SH 4-Pin Cable - 50mm Long</li> <li>Tiny Code Reader from Useful Sensors</li> <li>Micro servo - TowerPro SG92R - You can also use any generic SG90/SG92 form factor servo.</li> <li>7x Socket Head Cap Screw: M2-0.4 Thread Size, 8 mm Lg, Std, Black Oxide, Steel, Class 12.9, 100 PK</li> <li>7x Hex Nut: M2-0.40 Thread, 4 mm Hex Wd, 1.6 mm Hex Ht, Steel, Class 8, Zinc Plated, 100 PK</li> <li>3x Female-to-male jumper wires - Shorter the better. These are 10cm.</li> <li>Adhesive. Hot glue if you want some margin of error, superglue if you want a more \"secure\" experience.</li> </ul>"},{"location":"building_the_lock/#optional-but-good-to-have","title":"Optional, but good to have","text":"<ul> <li>Loctite Threadlocker Blue - Makes the lock more tamper resistant.</li> <li>Tiny cable tie</li> <li>4mm Nut driver - Definitely makes tightening the nuts easier, but far from necessary. Also you probably want a magnetized one, but this is what I have.</li> </ul>"},{"location":"building_the_lock/#tools","title":"Tools","text":"<ul> <li>Soldering iron</li> <li>Technical screwdriver (T6 bit)</li> </ul>"},{"location":"building_the_lock/#3d-files","title":"3D Files","text":"<p>You can get the full kit of parts here: Full kit</p> <p>I personally use Prusa slicer + the Prusa MINI+ for most builds. I use organic supports, 15% infill, and the 0.20mm SPEED profile. Feel free to adjust as necessary. I recommend printing with PLA.</p>"},{"location":"building_the_lock/#assembly","title":"Assembly","text":""},{"location":"building_the_lock/#step-1-print-the-parts","title":"Step 1: Print the parts","text":"<ul> <li>3D printer</li> <li>Several hours</li> </ul>"},{"location":"building_the_lock/#step-2-solder-headers-to-esp32-s3","title":"Step 2: Solder headers to ESP32-S3","text":"<ul> <li>ESP32-S3 + included headers</li> </ul> <p>``</p> <p>Use a pair of pliers and break off 3 headers from the full strip that comes with the ESP32-S3.</p> <p>You'll solder these headers (short-side through top) across 3V, GND, and A0. See picture. Also check out the pinout guide from Adafruit.</p>"},{"location":"building_the_lock/#step-3-flash-the-firmware","title":"Step 3: Flash the firmware","text":"<p>`</p> <p>Hold down D0 and press Reset. Flash the firmware with:</p> <pre><code>espflash flash --monitor --partition-table partitions.csv --no-skip --erase-parts otadata\n</code></pre> <p>If it looks like it succeeded but says \"Waiting for download\" you just need to reset it one more time.</p> <p>You should see the boot screen followed by \"Needs configuration.\"</p> <p>We do this now because we need the firmware to calibrate the servo.</p>"},{"location":"building_the_lock/#step-4-assemble-servo-bracket","title":"Step 4: Assemble servo bracket","text":"<ul> <li>2x 2mm screws</li> <li>2x hex nuts</li> <li>1x mounting bracket</li> <li>1x SG92 servo (with single-ended horn, and small screw that came with it) </li> </ul> <p>`</p>"},{"location":"building_the_lock/#step-5-wire-servo-to-esp32-s3","title":"Step 5: Wire servo to ESP32-S3.","text":"<ul> <li>3x jumper wires</li> </ul> <p>`</p> <p>Unfortunately, the board layout is 3V, GND, A0 and the servo's wiring is GND, 3V, Signal. Use the jumper wires to connect the servo the board headers but swap the power and ground.</p> <p>Connect USB power to the ESP32-S3 and you will probably hear a quick buzz. The servo is now in the \"down\" angle position so we can mount the horn.</p>"},{"location":"building_the_lock/#alternative","title":"Alternative","text":"<p>You can also pop the pins out of the servo connector and swap them there and omit this step.</p>"},{"location":"building_the_lock/#step-6-mount-the-horn","title":"Step 6: Mount the horn","text":"<p>`</p> <p>Mount the horn at 6 as if it were a clock. Connect power back to the ESP32-S3 and make sure the servo starts at 6. Toggle the lock on the second screen (D2 to change screen and then by pressing D1, the middle button). It should freely rotate to a 3 o'clock position and back. If it does, use the small-sized screw and mount the horn permanently. Try not to rotate the horn while tightening.</p>"},{"location":"building_the_lock/#step-7-mount-esp32-s3-to-lid","title":"Step 7: Mount ESP32-S3 to lid","text":"<ul> <li>4x bolts</li> <li>4x nuts</li> </ul> <p>`</p> <p>`</p> <p>`</p> <p>`</p> <p>Use a pair of tweezers (or similar) to remove the small section where the headers will fit from the underside of the 3D print.</p> <p>Attach all the bolts and nuts. Use the thread locker to make sure they don't loosen. Also makes sure that subs can't just open it by shaking :-).</p>"},{"location":"building_the_lock/#step-8-wire-and-mount-code-reader","title":"Step 8: Wire and mount code reader","text":"<ul> <li>Tiny code reader</li> <li>Stemma QT cable</li> <li>1 bolt</li> <li>1 nut</li> <li>2 spacers from 3D print</li> </ul> <p>`</p> <p>`</p> <p>`</p> <p>Connect the tiny code reader with the stemma QT cable to the main board.</p> <p>Mount the tiny code reader with the bolt + nut.</p> <p>I use 2 \"spacers\" to secure the code reader in place because it only has the one screw mount hole. I use a tiny amount of activator on the board and superglue the spacers above and below the reader. See pic.</p>"},{"location":"building_the_lock/#step-9-test-and-then-make-wire-connections-permanent","title":"Step 9: Test and then make wire connections permanent","text":"<p>Plug it in and cycle the lock. Try and scan a wifi code and make sure it connects. When you're satisfied it's all working make the connections permanent with your adhesive of choice.</p>"},{"location":"building_the_lock/#step-10-mount-servo-to-main-body","title":"Step 10: Mount servo to main body","text":"<p>`</p>"},{"location":"building_the_lock/#step-11-mount-technical-lid-to-main-body","title":"Step 11: Mount technical lid to main body","text":"<p>`</p> <p>I use a tiny cable tie to make this a little easier and a little more organized.</p> <p>Use your adhesive to secure the front lid to the body.</p> <p>`</p>"},{"location":"building_the_lock/#step-12-seal-top","title":"Step 12: Seal top","text":"<p>`</p> <p>`</p> <p>I use superglue on the left sill, the right sill, and a tiny bit across the front where all the technical parts are mounted. If you're using hot glue be sure wherever you apply it doesn't interfere with the tray sliding in and out.</p> <p>In order to get the best seal I recommend leaving a heavy weight on it while it cures. I have a tupperware full of change for this. Give it an hour or two.</p>"},{"location":"building_the_lock/#done","title":"Done!","text":"<p>`</p>"},{"location":"setting_up_the_lock/","title":"Initial Setup","text":""},{"location":"setting_up_the_lock/#getting-on-wi-fi","title":"Getting on Wi-Fi","text":"<p>The first, and really only step, to completing setup is getting the lock on Wi-Fi.</p> <p>There's a few ways to do this.</p> <p>Note: The generated code is a standard WPA3 Wi-Fi URI. Anything offering to make you a Wi-fi QR code is probably going to work. The spec.</p> <ul> <li>There's a helper page included in the webapp called the Wi-Fi helper. You can put your SSID/Network name and password (nothing is transmitted or leaves the page, you can verify it in the source) and it will give you a QR code that you can read with the lock.</li> <li>If you're using newer iOS or OSX the \"Passwords\" app can make scannable QR codes directly with your saved credentials. Share Wi-Fi Network Passwords Using QR Codes.</li> <li>Windows 11 has something similar. Windows 11 24H2: Create QR Code to share Wi-Fi access</li> </ul>"},{"location":"setting_up_the_lock/#verifying-it-worked","title":"Verifying it worked","text":"<p>Once the lock is online it will try and connect to the default message broker at <code>wss://tartarus-mqtt.subjugated.club:4447/mqtt</code>. If it succeeds it will download a configuration blob containing everything it needs to get create login credentials for you.</p> <p>Give it a reset and a scannable QR code should be on the display after it boots.</p>"},{"location":"sub_user_guide/","title":"Lock User Guide - So You Want Someone To Hold Your Keys","text":""},{"location":"sub_user_guide/#step-1-complete-build-setup","title":"Step 1: Complete Build + Setup","text":"<p>Make sure it's built, online, and working.</p>"},{"location":"sub_user_guide/#step-2-login","title":"Step 2: Login","text":"<p>Scan the QR code on the front of the lock. It will give you a magical URL that will sign you into the website as a <code>LockUserSession</code>.</p>"},{"location":"sub_user_guide/#step-3-share-links","title":"Step 3: Share Links","text":"<p>You'll see two links. One is your \"Share\" link and one is your \"Total Control\" link/token. If you send someone the \"Share\" link and they write a contract you'll be given the option to accept/reject it. If you send someone the \"Total Control\" link you will not be prompted, and the contract will be sent directly to the hardware and accepted. You've been warned.</p> <p>You can tell the tokens apart because share tokens start with <code>s-</code> and total control tokens start with <code>tc-</code>.</p>"},{"location":"sub_user_guide/#step-4-acceptreject-contracts","title":"Step 4: Accept/Reject Contracts","text":"<p>Decide who you want to accept a contract from.</p> <p>Make sure to read the terms. And especially note if any bots have been listed and with what permissions.</p>"},{"location":"sub_user_guide/#step-5-wait-for-release","title":"Step 5: Wait For Release","text":"<p>Enjoy. If temporary unlocks are allowed you can go to the lock screen on the lock and use the middle button to toggle the lock.</p>"},{"location":"usage_guide_for_authors/","title":"Author Guide - So You Want To Hold Some Keys","text":""},{"location":"usage_guide_for_authors/#step-1-get-a-keypair","title":"Step 1: Get A Keypair","text":"<p>Generate a keypair using the key generator. This keypair is how you login and what the software will use to sign all your contracts and commands.</p> <p>Do not share it. Especially with your sub. It's functionally a password. Anyone with this image/key file can release or unlock a contract.</p> <p>Protect it. Treat it like a physical key your sub handed you. If you lose it you'll need to find someone to abort the contract.</p>"},{"location":"usage_guide_for_authors/#step-2-login","title":"Step 2: Login","text":""},{"location":"usage_guide_for_authors/#step-3-get-a-token-from-your-sub","title":"Step 3: Get A Token From Your Sub","text":"<p>Every sub has two links. One is the \"share\" link the other is the \"total control\" link. The \"share\" token starts with <code>s-</code> and the total control token starts with <code>tc-</code>.</p> <p>An <code>s-</code> token will let you write a contract and send it to your sub for review and accept/reject. A <code>tc-</code> token will let you write a contract and issue it directly. If the lock is online it will auto-accept it. The website will let you know which you have.</p> <p>When you load the link it will become a <code>KnownToken</code> and it will always be available on the website under \"Lock sessions\". You can name the token so you can remember who it came from.</p>"},{"location":"usage_guide_for_authors/#step-4-write-a-contract","title":"Step 4: Write A Contract","text":"<p>Go nuts. Add bots. Whatever.</p>"},{"location":"usage_guide_for_authors/#step-4-enjoy","title":"Step 4: Enjoy","text":"<p>\ud83d\ude08</p>"},{"location":"usage_guide_for_authors/#step-5-release","title":"Step 5: Release","text":"<p>When you're done you'll have a button for Release. That will end the contract.</p>"}]}