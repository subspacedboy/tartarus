namespace club.subjugated.fb.message;

table TimeEndCondition {
  seconds: ulong;
}

table WhenISaySo {
}

union EndCondition {
  TimeEndCondition,
  WhenISaySo
}

table WebHook {
  address: string;
}

table TemporaryUnlockRules {
  // If greater than zero it should act like a counter.
  max_unlocks: ushort;

  time_limit: ushort;
}

table Contract {
  public_key: [ubyte];

  nonce: [ubyte];
  confirm_code: [ubyte];
  notes: string;

  // If this contract is able to be loaded, it cannot be removed
  // without explicit permission.
  is_unremovable: bool;

  end_condition: EndCondition;

  webhooks: [WebHook];

  // If true, subject can freely cycle the lock.
  is_temporary_unlock_allowed: bool;
  unlock_rules : TemporaryUnlockRules;
}

table SimpleContract {
  public_key: [ubyte];

  nonce: [ubyte];
  confirm_code: [ubyte];

  // If this contract is able to be loaded, it cannot be removed
  // without explicit permission.
  is_unremovable: bool;

  end_condition: EndCondition;

  // If true, subject can freely cycle the lock.
  is_temporary_unlock_allowed: bool;
  unlock_rules : TemporaryUnlockRules;
}


enum UpdateType : byte { Undefined = 0, Started, Locked, Unlocked, Error }

table LockUpdateEvent {
    public_key: [ubyte];
    session: string;
    body: string;
    this_update_type: UpdateType;
}

//enum CommandType : byte { Undefined = 0, AcceptContract, Lock, Unlock, Release, Ping }

// Commands tell the lock what to do. They're always signed, so it's really just a
// wrapper for cleaner code.
//table Command {
//    signed_message: [ubyte];
//    command_type: CommandType;
//}

table LockCommand {}
table UnlockCommand {}
table ReleaseCommand {}

union MessagePayload {
  Contract, LockUpdateEvent, LockCommand, UnlockCommand, ReleaseCommand
}

table SignedMessage {
  signature: [ubyte];
  payload: MessagePayload;
}

table Configuration {
  coordinator_address: string;
  safety_key: [ubyte];
}

root_type SignedMessage;