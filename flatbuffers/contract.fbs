namespace club.subjugated.fb.message;

table TimeEndCondition {
  seconds: ulong;
}

table WhenISaySo {
}

union EndCondition {
  TimeEndCondition,
  WhenISaySo
}

table WebHook {
  address: string;
}

table TemporaryUnlockRules {
  // If greater than zero it should act like a counter.
  max_unlocks: ushort;

  time_limit: ushort;
}

table Contract {
  serial_number: ushort;

  public_key: [ubyte];

  nonce: [ubyte];
  confirm_code: [ubyte];

  end_condition: EndCondition;
  webhooks: [WebHook];

  // If true, subject can freely cycle the lock.
  is_temporary_unlock_allowed: bool;
  unlock_rules : TemporaryUnlockRules;
}

// enum UpdateType : byte { Undefined = 0, Started, Acknowledgement }

table StartedUpdate {
    public_key: [ubyte];
    session: string;

    started_with_local_contract: bool;

    current_contract_serial: ushort;
    is_locked: bool;
}

table PeriodicUpdate {
  session: string;
  is_locked: bool;
  current_contract_serial: ushort;
}

table Acknowledgement {
    public_key: [ubyte];
    session: string;

    serial_number: ushort;
    counter: ushort;
}

table Error {
    public_key: [ubyte];
    session: string;

    serial_number: ushort;
    counter: ushort;

    message: string;
}

table LockCommand {
    contract_serial_number: ushort;
    serial_number: ushort;
    counter: ushort;
}
table UnlockCommand {
    contract_serial_number: ushort;
    serial_number: ushort;
    counter: ushort;
}
table ReleaseCommand {
    contract_serial_number: ushort;
    serial_number: ushort;
    counter: ushort;
}
table AbortCommand {
    contract_serial_number: ushort;
    serial_number: ushort;
    counter: ushort;
}

union MessagePayload {
  Contract, LockCommand, UnlockCommand, ReleaseCommand, StartedUpdate, PeriodicUpdate, Acknowledgement, Error, AbortCommand
}

table SignedMessage {
  signature: [ubyte];
  payload: MessagePayload;
}

root_type SignedMessage;