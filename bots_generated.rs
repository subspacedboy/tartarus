// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod club {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod subjugated {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod fb {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod bots {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE_PAYLOAD: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE_PAYLOAD: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE_PAYLOAD: [MessagePayload; 11] = [
  MessagePayload::NONE,
  MessagePayload::GetContractRequest,
  MessagePayload::GetContractResponse,
  MessagePayload::CreateCommandRequest,
  MessagePayload::CreateCommandResponse,
  MessagePayload::CreateContractRequest,
  MessagePayload::CreateContractResponse,
  MessagePayload::GetLockSessionRequest,
  MessagePayload::GetLockSessionResponse,
  MessagePayload::CreateMessageRequest,
  MessagePayload::CreateMessageResponse,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MessagePayload(pub u8);
#[allow(non_upper_case_globals)]
impl MessagePayload {
  pub const NONE: Self = Self(0);
  pub const GetContractRequest: Self = Self(1);
  pub const GetContractResponse: Self = Self(2);
  pub const CreateCommandRequest: Self = Self(3);
  pub const CreateCommandResponse: Self = Self(4);
  pub const CreateContractRequest: Self = Self(5);
  pub const CreateContractResponse: Self = Self(6);
  pub const GetLockSessionRequest: Self = Self(7);
  pub const GetLockSessionResponse: Self = Self(8);
  pub const CreateMessageRequest: Self = Self(9);
  pub const CreateMessageResponse: Self = Self(10);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::GetContractRequest,
    Self::GetContractResponse,
    Self::CreateCommandRequest,
    Self::CreateCommandResponse,
    Self::CreateContractRequest,
    Self::CreateContractResponse,
    Self::GetLockSessionRequest,
    Self::GetLockSessionResponse,
    Self::CreateMessageRequest,
    Self::CreateMessageResponse,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::GetContractRequest => Some("GetContractRequest"),
      Self::GetContractResponse => Some("GetContractResponse"),
      Self::CreateCommandRequest => Some("CreateCommandRequest"),
      Self::CreateCommandResponse => Some("CreateCommandResponse"),
      Self::CreateContractRequest => Some("CreateContractRequest"),
      Self::CreateContractResponse => Some("CreateContractResponse"),
      Self::GetLockSessionRequest => Some("GetLockSessionRequest"),
      Self::GetLockSessionResponse => Some("GetLockSessionResponse"),
      Self::CreateMessageRequest => Some("CreateMessageRequest"),
      Self::CreateMessageResponse => Some("CreateMessageResponse"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MessagePayload {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MessagePayload {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MessagePayload {
    type Output = MessagePayload;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MessagePayload {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MessagePayload {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MessagePayload {}
pub struct MessagePayloadUnionTableOffset {}

pub enum CreateContractRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CreateContractRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateContractRequest<'a> {
  type Inner = CreateContractRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CreateContractRequest<'a> {
  pub const VT_SHAREABLETOKEN: flatbuffers::VOffsetT = 4;
  pub const VT_CONTRACT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CreateContractRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CreateContractRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<CreateContractRequest<'bldr>> {
    let mut builder = CreateContractRequestBuilder::new(_fbb);
    if let Some(x) = args.contract { builder.add_contract(x); }
    if let Some(x) = args.shareableToken { builder.add_shareableToken(x); }
    builder.finish()
  }


  #[inline]
  pub fn shareableToken(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CreateContractRequest::VT_SHAREABLETOKEN, None)}
  }
  #[inline]
  pub fn contract(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CreateContractRequest::VT_CONTRACT, None)}
  }
}

impl flatbuffers::Verifiable for CreateContractRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("shareableToken", Self::VT_SHAREABLETOKEN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("contract", Self::VT_CONTRACT, false)?
     .finish();
    Ok(())
  }
}
pub struct CreateContractRequestArgs<'a> {
    pub shareableToken: Option<flatbuffers::WIPOffset<&'a str>>,
    pub contract: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for CreateContractRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    CreateContractRequestArgs {
      shareableToken: None,
      contract: None,
    }
  }
}

pub struct CreateContractRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CreateContractRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_shareableToken(&mut self, shareableToken: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateContractRequest::VT_SHAREABLETOKEN, shareableToken);
  }
  #[inline]
  pub fn add_contract(&mut self, contract: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateContractRequest::VT_CONTRACT, contract);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CreateContractRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CreateContractRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreateContractRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CreateContractRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CreateContractRequest");
      ds.field("shareableToken", &self.shareableToken());
      ds.field("contract", &self.contract());
      ds.finish()
  }
}
pub enum CreateContractResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CreateContractResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateContractResponse<'a> {
  type Inner = CreateContractResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CreateContractResponse<'a> {
  pub const VT_CONTRACT_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CreateContractResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CreateContractResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<CreateContractResponse<'bldr>> {
    let mut builder = CreateContractResponseBuilder::new(_fbb);
    if let Some(x) = args.contract_name { builder.add_contract_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn contract_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CreateContractResponse::VT_CONTRACT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for CreateContractResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("contract_name", Self::VT_CONTRACT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct CreateContractResponseArgs<'a> {
    pub contract_name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CreateContractResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    CreateContractResponseArgs {
      contract_name: None,
    }
  }
}

pub struct CreateContractResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CreateContractResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_contract_name(&mut self, contract_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateContractResponse::VT_CONTRACT_NAME, contract_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CreateContractResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CreateContractResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreateContractResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CreateContractResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CreateContractResponse");
      ds.field("contract_name", &self.contract_name());
      ds.finish()
  }
}
pub enum GetContractRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetContractRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetContractRequest<'a> {
  type Inner = GetContractRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetContractRequest<'a> {
  pub const VT_LOCK_SESSION: flatbuffers::VOffsetT = 4;
  pub const VT_CONTRACT_SERIAL_NUMBER: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetContractRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetContractRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<GetContractRequest<'bldr>> {
    let mut builder = GetContractRequestBuilder::new(_fbb);
    if let Some(x) = args.lock_session { builder.add_lock_session(x); }
    builder.add_contract_serial_number(args.contract_serial_number);
    builder.finish()
  }


  #[inline]
  pub fn lock_session(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GetContractRequest::VT_LOCK_SESSION, None)}
  }
  #[inline]
  pub fn contract_serial_number(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(GetContractRequest::VT_CONTRACT_SERIAL_NUMBER, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GetContractRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lock_session", Self::VT_LOCK_SESSION, false)?
     .visit_field::<u16>("contract_serial_number", Self::VT_CONTRACT_SERIAL_NUMBER, false)?
     .finish();
    Ok(())
  }
}
pub struct GetContractRequestArgs<'a> {
    pub lock_session: Option<flatbuffers::WIPOffset<&'a str>>,
    pub contract_serial_number: u16,
}
impl<'a> Default for GetContractRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetContractRequestArgs {
      lock_session: None,
      contract_serial_number: 0,
    }
  }
}

pub struct GetContractRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetContractRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_lock_session(&mut self, lock_session: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetContractRequest::VT_LOCK_SESSION, lock_session);
  }
  #[inline]
  pub fn add_contract_serial_number(&mut self, contract_serial_number: u16) {
    self.fbb_.push_slot::<u16>(GetContractRequest::VT_CONTRACT_SERIAL_NUMBER, contract_serial_number, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetContractRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetContractRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetContractRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetContractRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetContractRequest");
      ds.field("lock_session", &self.lock_session());
      ds.field("contract_serial_number", &self.contract_serial_number());
      ds.finish()
  }
}
pub enum GetContractResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetContractResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetContractResponse<'a> {
  type Inner = GetContractResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetContractResponse<'a> {
  pub const VT_NEXT_COUNTER: flatbuffers::VOffsetT = 4;
  pub const VT_STATE: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetContractResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetContractResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<GetContractResponse<'bldr>> {
    let mut builder = GetContractResponseBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.state { builder.add_state(x); }
    builder.add_next_counter(args.next_counter);
    builder.finish()
  }


  #[inline]
  pub fn next_counter(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(GetContractResponse::VT_NEXT_COUNTER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn state(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GetContractResponse::VT_STATE, None)}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GetContractResponse::VT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for GetContractResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("next_counter", Self::VT_NEXT_COUNTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("state", Self::VT_STATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct GetContractResponseArgs<'a> {
    pub next_counter: u16,
    pub state: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for GetContractResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetContractResponseArgs {
      next_counter: 0,
      state: None,
      name: None,
    }
  }
}

pub struct GetContractResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetContractResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_next_counter(&mut self, next_counter: u16) {
    self.fbb_.push_slot::<u16>(GetContractResponse::VT_NEXT_COUNTER, next_counter, 0);
  }
  #[inline]
  pub fn add_state(&mut self, state: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetContractResponse::VT_STATE, state);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetContractResponse::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetContractResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetContractResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetContractResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetContractResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetContractResponse");
      ds.field("next_counter", &self.next_counter());
      ds.field("state", &self.state());
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum CreateCommandRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CreateCommandRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateCommandRequest<'a> {
  type Inner = CreateCommandRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CreateCommandRequest<'a> {
  pub const VT_COMMAND_BODY: flatbuffers::VOffsetT = 4;
  pub const VT_SHAREABLE_TOKEN: flatbuffers::VOffsetT = 6;
  pub const VT_CONTRACT_NAME: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CreateCommandRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CreateCommandRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<CreateCommandRequest<'bldr>> {
    let mut builder = CreateCommandRequestBuilder::new(_fbb);
    if let Some(x) = args.contract_name { builder.add_contract_name(x); }
    if let Some(x) = args.shareable_token { builder.add_shareable_token(x); }
    if let Some(x) = args.command_body { builder.add_command_body(x); }
    builder.finish()
  }


  #[inline]
  pub fn command_body(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CreateCommandRequest::VT_COMMAND_BODY, None)}
  }
  #[inline]
  pub fn shareable_token(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CreateCommandRequest::VT_SHAREABLE_TOKEN, None)}
  }
  #[inline]
  pub fn contract_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CreateCommandRequest::VT_CONTRACT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for CreateCommandRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("command_body", Self::VT_COMMAND_BODY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("shareable_token", Self::VT_SHAREABLE_TOKEN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("contract_name", Self::VT_CONTRACT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct CreateCommandRequestArgs<'a> {
    pub command_body: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub shareable_token: Option<flatbuffers::WIPOffset<&'a str>>,
    pub contract_name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CreateCommandRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    CreateCommandRequestArgs {
      command_body: None,
      shareable_token: None,
      contract_name: None,
    }
  }
}

pub struct CreateCommandRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CreateCommandRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_command_body(&mut self, command_body: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateCommandRequest::VT_COMMAND_BODY, command_body);
  }
  #[inline]
  pub fn add_shareable_token(&mut self, shareable_token: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateCommandRequest::VT_SHAREABLE_TOKEN, shareable_token);
  }
  #[inline]
  pub fn add_contract_name(&mut self, contract_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateCommandRequest::VT_CONTRACT_NAME, contract_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CreateCommandRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CreateCommandRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreateCommandRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CreateCommandRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CreateCommandRequest");
      ds.field("command_body", &self.command_body());
      ds.field("shareable_token", &self.shareable_token());
      ds.field("contract_name", &self.contract_name());
      ds.finish()
  }
}
pub enum CreateCommandResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CreateCommandResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateCommandResponse<'a> {
  type Inner = CreateCommandResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CreateCommandResponse<'a> {
  pub const VT_ERROR: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CreateCommandResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CreateCommandResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<CreateCommandResponse<'bldr>> {
    let mut builder = CreateCommandResponseBuilder::new(_fbb);
    if let Some(x) = args.error { builder.add_error(x); }
    builder.finish()
  }


  #[inline]
  pub fn error(&self) -> Option<Error<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Error>>(CreateCommandResponse::VT_ERROR, None)}
  }
}

impl flatbuffers::Verifiable for CreateCommandResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Error>>("error", Self::VT_ERROR, false)?
     .finish();
    Ok(())
  }
}
pub struct CreateCommandResponseArgs<'a> {
    pub error: Option<flatbuffers::WIPOffset<Error<'a>>>,
}
impl<'a> Default for CreateCommandResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    CreateCommandResponseArgs {
      error: None,
    }
  }
}

pub struct CreateCommandResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CreateCommandResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_error(&mut self, error: flatbuffers::WIPOffset<Error<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Error>>(CreateCommandResponse::VT_ERROR, error);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CreateCommandResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CreateCommandResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreateCommandResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CreateCommandResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CreateCommandResponse");
      ds.field("error", &self.error());
      ds.finish()
  }
}
pub enum GetLockSessionRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetLockSessionRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetLockSessionRequest<'a> {
  type Inner = GetLockSessionRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetLockSessionRequest<'a> {
  pub const VT_SHAREABLE_TOKEN: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetLockSessionRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetLockSessionRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<GetLockSessionRequest<'bldr>> {
    let mut builder = GetLockSessionRequestBuilder::new(_fbb);
    if let Some(x) = args.shareable_token { builder.add_shareable_token(x); }
    builder.finish()
  }


  #[inline]
  pub fn shareable_token(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GetLockSessionRequest::VT_SHAREABLE_TOKEN, None)}
  }
}

impl flatbuffers::Verifiable for GetLockSessionRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("shareable_token", Self::VT_SHAREABLE_TOKEN, false)?
     .finish();
    Ok(())
  }
}
pub struct GetLockSessionRequestArgs<'a> {
    pub shareable_token: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for GetLockSessionRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetLockSessionRequestArgs {
      shareable_token: None,
    }
  }
}

pub struct GetLockSessionRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetLockSessionRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_shareable_token(&mut self, shareable_token: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetLockSessionRequest::VT_SHAREABLE_TOKEN, shareable_token);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetLockSessionRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetLockSessionRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetLockSessionRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetLockSessionRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetLockSessionRequest");
      ds.field("shareable_token", &self.shareable_token());
      ds.finish()
  }
}
pub enum GetLockSessionResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetLockSessionResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetLockSessionResponse<'a> {
  type Inner = GetLockSessionResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetLockSessionResponse<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 6;
  pub const VT_AVAILABLE_FOR_CONTRACT: flatbuffers::VOffsetT = 8;
  pub const VT_ERROR: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetLockSessionResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetLockSessionResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<GetLockSessionResponse<'bldr>> {
    let mut builder = GetLockSessionResponseBuilder::new(_fbb);
    if let Some(x) = args.error { builder.add_error(x); }
    if let Some(x) = args.public_key { builder.add_public_key(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_available_for_contract(args.available_for_contract);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GetLockSessionResponse::VT_NAME, None)}
  }
  #[inline]
  pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GetLockSessionResponse::VT_PUBLIC_KEY, None)}
  }
  #[inline]
  pub fn available_for_contract(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GetLockSessionResponse::VT_AVAILABLE_FOR_CONTRACT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn error(&self) -> Option<Error<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Error>>(GetLockSessionResponse::VT_ERROR, None)}
  }
}

impl flatbuffers::Verifiable for GetLockSessionResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<bool>("available_for_contract", Self::VT_AVAILABLE_FOR_CONTRACT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Error>>("error", Self::VT_ERROR, false)?
     .finish();
    Ok(())
  }
}
pub struct GetLockSessionResponseArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub available_for_contract: bool,
    pub error: Option<flatbuffers::WIPOffset<Error<'a>>>,
}
impl<'a> Default for GetLockSessionResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetLockSessionResponseArgs {
      name: None,
      public_key: None,
      available_for_contract: false,
      error: None,
    }
  }
}

pub struct GetLockSessionResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetLockSessionResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetLockSessionResponse::VT_NAME, name);
  }
  #[inline]
  pub fn add_public_key(&mut self, public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetLockSessionResponse::VT_PUBLIC_KEY, public_key);
  }
  #[inline]
  pub fn add_available_for_contract(&mut self, available_for_contract: bool) {
    self.fbb_.push_slot::<bool>(GetLockSessionResponse::VT_AVAILABLE_FOR_CONTRACT, available_for_contract, false);
  }
  #[inline]
  pub fn add_error(&mut self, error: flatbuffers::WIPOffset<Error<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Error>>(GetLockSessionResponse::VT_ERROR, error);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetLockSessionResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetLockSessionResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetLockSessionResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetLockSessionResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetLockSessionResponse");
      ds.field("name", &self.name());
      ds.field("public_key", &self.public_key());
      ds.field("available_for_contract", &self.available_for_contract());
      ds.field("error", &self.error());
      ds.finish()
  }
}
pub enum CreateMessageRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CreateMessageRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateMessageRequest<'a> {
  type Inner = CreateMessageRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CreateMessageRequest<'a> {
  pub const VT_CONTRACT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CreateMessageRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CreateMessageRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<CreateMessageRequest<'bldr>> {
    let mut builder = CreateMessageRequestBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    if let Some(x) = args.contract_name { builder.add_contract_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn contract_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CreateMessageRequest::VT_CONTRACT_NAME, None)}
  }
  #[inline]
  pub fn message(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CreateMessageRequest::VT_MESSAGE, None)}
  }
}

impl flatbuffers::Verifiable for CreateMessageRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("contract_name", Self::VT_CONTRACT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct CreateMessageRequestArgs<'a> {
    pub contract_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CreateMessageRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    CreateMessageRequestArgs {
      contract_name: None,
      message: None,
    }
  }
}

pub struct CreateMessageRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CreateMessageRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_contract_name(&mut self, contract_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateMessageRequest::VT_CONTRACT_NAME, contract_name);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateMessageRequest::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CreateMessageRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CreateMessageRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreateMessageRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CreateMessageRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CreateMessageRequest");
      ds.field("contract_name", &self.contract_name());
      ds.field("message", &self.message());
      ds.finish()
  }
}
pub enum CreateMessageResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CreateMessageResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateMessageResponse<'a> {
  type Inner = CreateMessageResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CreateMessageResponse<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CreateMessageResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args CreateMessageResponseArgs
  ) -> flatbuffers::WIPOffset<CreateMessageResponse<'bldr>> {
    let mut builder = CreateMessageResponseBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for CreateMessageResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct CreateMessageResponseArgs {
}
impl<'a> Default for CreateMessageResponseArgs {
  #[inline]
  fn default() -> Self {
    CreateMessageResponseArgs {
    }
  }
}

pub struct CreateMessageResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CreateMessageResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CreateMessageResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CreateMessageResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreateMessageResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CreateMessageResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CreateMessageResponse");
      ds.finish()
  }
}
pub enum ErrorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Error<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Error<'a> {
  type Inner = Error<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Error<'a> {
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Error { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ErrorArgs<'args>
  ) -> flatbuffers::WIPOffset<Error<'bldr>> {
    let mut builder = ErrorBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    builder.finish()
  }


  #[inline]
  pub fn message(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Error::VT_MESSAGE, None)}
  }
}

impl flatbuffers::Verifiable for Error<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct ErrorArgs<'a> {
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ErrorArgs<'a> {
  #[inline]
  fn default() -> Self {
    ErrorArgs {
      message: None,
    }
  }
}

pub struct ErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ErrorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Error::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ErrorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ErrorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Error<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Error<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Error");
      ds.field("message", &self.message());
      ds.finish()
  }
}
pub enum BotApiMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BotApiMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BotApiMessage<'a> {
  type Inner = BotApiMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BotApiMessage<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_PAYLOAD: flatbuffers::VOffsetT = 8;
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BotApiMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BotApiMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<BotApiMessage<'bldr>> {
    let mut builder = BotApiMessageBuilder::new(_fbb);
    builder.add_request_id(args.request_id);
    if let Some(x) = args.payload { builder.add_payload(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_payload_type(args.payload_type);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BotApiMessage::VT_NAME, None)}
  }
  #[inline]
  pub fn payload_type(&self) -> MessagePayload {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MessagePayload>(BotApiMessage::VT_PAYLOAD_TYPE, Some(MessagePayload::NONE)).unwrap()}
  }
  #[inline]
  pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(BotApiMessage::VT_PAYLOAD, None)}
  }
  #[inline]
  pub fn request_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(BotApiMessage::VT_REQUEST_ID, Some(0)).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_get_contract_request(&self) -> Option<GetContractRequest<'a>> {
    if self.payload_type() == MessagePayload::GetContractRequest {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GetContractRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_get_contract_response(&self) -> Option<GetContractResponse<'a>> {
    if self.payload_type() == MessagePayload::GetContractResponse {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GetContractResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_create_command_request(&self) -> Option<CreateCommandRequest<'a>> {
    if self.payload_type() == MessagePayload::CreateCommandRequest {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CreateCommandRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_create_command_response(&self) -> Option<CreateCommandResponse<'a>> {
    if self.payload_type() == MessagePayload::CreateCommandResponse {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CreateCommandResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_create_contract_request(&self) -> Option<CreateContractRequest<'a>> {
    if self.payload_type() == MessagePayload::CreateContractRequest {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CreateContractRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_create_contract_response(&self) -> Option<CreateContractResponse<'a>> {
    if self.payload_type() == MessagePayload::CreateContractResponse {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CreateContractResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_get_lock_session_request(&self) -> Option<GetLockSessionRequest<'a>> {
    if self.payload_type() == MessagePayload::GetLockSessionRequest {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GetLockSessionRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_get_lock_session_response(&self) -> Option<GetLockSessionResponse<'a>> {
    if self.payload_type() == MessagePayload::GetLockSessionResponse {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GetLockSessionResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_create_message_request(&self) -> Option<CreateMessageRequest<'a>> {
    if self.payload_type() == MessagePayload::CreateMessageRequest {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CreateMessageRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_create_message_response(&self) -> Option<CreateMessageResponse<'a>> {
    if self.payload_type() == MessagePayload::CreateMessageResponse {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CreateMessageResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for BotApiMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_union::<MessagePayload, _>("payload_type", Self::VT_PAYLOAD_TYPE, "payload", Self::VT_PAYLOAD, false, |key, v, pos| {
        match key {
          MessagePayload::GetContractRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetContractRequest>>("MessagePayload::GetContractRequest", pos),
          MessagePayload::GetContractResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetContractResponse>>("MessagePayload::GetContractResponse", pos),
          MessagePayload::CreateCommandRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CreateCommandRequest>>("MessagePayload::CreateCommandRequest", pos),
          MessagePayload::CreateCommandResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CreateCommandResponse>>("MessagePayload::CreateCommandResponse", pos),
          MessagePayload::CreateContractRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CreateContractRequest>>("MessagePayload::CreateContractRequest", pos),
          MessagePayload::CreateContractResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CreateContractResponse>>("MessagePayload::CreateContractResponse", pos),
          MessagePayload::GetLockSessionRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetLockSessionRequest>>("MessagePayload::GetLockSessionRequest", pos),
          MessagePayload::GetLockSessionResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetLockSessionResponse>>("MessagePayload::GetLockSessionResponse", pos),
          MessagePayload::CreateMessageRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CreateMessageRequest>>("MessagePayload::CreateMessageRequest", pos),
          MessagePayload::CreateMessageResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CreateMessageResponse>>("MessagePayload::CreateMessageResponse", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<i64>("request_id", Self::VT_REQUEST_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct BotApiMessageArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub payload_type: MessagePayload,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub request_id: i64,
}
impl<'a> Default for BotApiMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    BotApiMessageArgs {
      name: None,
      payload_type: MessagePayload::NONE,
      payload: None,
      request_id: 0,
    }
  }
}

pub struct BotApiMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BotApiMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BotApiMessage::VT_NAME, name);
  }
  #[inline]
  pub fn add_payload_type(&mut self, payload_type: MessagePayload) {
    self.fbb_.push_slot::<MessagePayload>(BotApiMessage::VT_PAYLOAD_TYPE, payload_type, MessagePayload::NONE);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BotApiMessage::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn add_request_id(&mut self, request_id: i64) {
    self.fbb_.push_slot::<i64>(BotApiMessage::VT_REQUEST_ID, request_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BotApiMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BotApiMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BotApiMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BotApiMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BotApiMessage");
      ds.field("name", &self.name());
      ds.field("payload_type", &self.payload_type());
      match self.payload_type() {
        MessagePayload::GetContractRequest => {
          if let Some(x) = self.payload_as_get_contract_request() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessagePayload::GetContractResponse => {
          if let Some(x) = self.payload_as_get_contract_response() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessagePayload::CreateCommandRequest => {
          if let Some(x) = self.payload_as_create_command_request() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessagePayload::CreateCommandResponse => {
          if let Some(x) = self.payload_as_create_command_response() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessagePayload::CreateContractRequest => {
          if let Some(x) = self.payload_as_create_contract_request() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessagePayload::CreateContractResponse => {
          if let Some(x) = self.payload_as_create_contract_response() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessagePayload::GetLockSessionRequest => {
          if let Some(x) = self.payload_as_get_lock_session_request() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessagePayload::GetLockSessionResponse => {
          if let Some(x) = self.payload_as_get_lock_session_response() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessagePayload::CreateMessageRequest => {
          if let Some(x) = self.payload_as_create_message_request() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessagePayload::CreateMessageResponse => {
          if let Some(x) = self.payload_as_create_message_response() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("payload", &x)
        },
      };
      ds.field("request_id", &self.request_id());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `BotApiMessage`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_bot_api_message_unchecked`.
pub fn root_as_bot_api_message(buf: &[u8]) -> Result<BotApiMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<BotApiMessage>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `BotApiMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_bot_api_message_unchecked`.
pub fn size_prefixed_root_as_bot_api_message(buf: &[u8]) -> Result<BotApiMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<BotApiMessage>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `BotApiMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_bot_api_message_unchecked`.
pub fn root_as_bot_api_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<BotApiMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<BotApiMessage<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `BotApiMessage` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_bot_api_message_unchecked`.
pub fn size_prefixed_root_as_bot_api_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<BotApiMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<BotApiMessage<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a BotApiMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `BotApiMessage`.
pub unsafe fn root_as_bot_api_message_unchecked(buf: &[u8]) -> BotApiMessage {
  flatbuffers::root_unchecked::<BotApiMessage>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed BotApiMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `BotApiMessage`.
pub unsafe fn size_prefixed_root_as_bot_api_message_unchecked(buf: &[u8]) -> BotApiMessage {
  flatbuffers::size_prefixed_root_unchecked::<BotApiMessage>(buf)
}
#[inline]
pub fn finish_bot_api_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<BotApiMessage<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_bot_api_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<BotApiMessage<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod bots
}  // pub mod fb
}  // pub mod subjugated
}  // pub mod club

