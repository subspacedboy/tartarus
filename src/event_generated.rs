// automatically generated by the FlatBuffers compiler, do not modify

// @generated

#![allow(clippy::all)]

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod club {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod subjugated {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};
        #[allow(unused_imports, dead_code)]
        pub mod fb {

            use core::cmp::Ordering;
            use core::mem;

            extern crate flatbuffers;
            use self::flatbuffers::{EndianScalar, Follow};
            #[allow(unused_imports, dead_code)]
            pub mod event {

                use core::cmp::Ordering;
                use core::mem;

                extern crate flatbuffers;
                use self::flatbuffers::{EndianScalar, Follow};

                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MIN_EVENT_TYPE: i8 = 0;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MAX_EVENT_TYPE: i8 = 6;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                #[allow(non_camel_case_types)]
                pub const ENUM_VALUES_EVENT_TYPE: [EventType; 7] = [
                    EventType::Undefined,
                    EventType::AcceptContract,
                    EventType::LocalLock,
                    EventType::LocalUnlock,
                    EventType::Lock,
                    EventType::Unlock,
                    EventType::ReleaseContract,
                ];

                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
                #[repr(transparent)]
                pub struct EventType(pub i8);
                #[allow(non_upper_case_globals)]
                impl EventType {
                    pub const Undefined: Self = Self(0);
                    pub const AcceptContract: Self = Self(1);
                    pub const LocalLock: Self = Self(2);
                    pub const LocalUnlock: Self = Self(3);
                    pub const Lock: Self = Self(4);
                    pub const Unlock: Self = Self(5);
                    pub const ReleaseContract: Self = Self(6);

                    pub const ENUM_MIN: i8 = 0;
                    pub const ENUM_MAX: i8 = 6;
                    pub const ENUM_VALUES: &'static [Self] = &[
                        Self::Undefined,
                        Self::AcceptContract,
                        Self::LocalLock,
                        Self::LocalUnlock,
                        Self::Lock,
                        Self::Unlock,
                        Self::ReleaseContract,
                    ];
                    /// Returns the variant's name or "" if unknown.
                    pub fn variant_name(self) -> Option<&'static str> {
                        match self {
                            Self::Undefined => Some("Undefined"),
                            Self::AcceptContract => Some("AcceptContract"),
                            Self::LocalLock => Some("LocalLock"),
                            Self::LocalUnlock => Some("LocalUnlock"),
                            Self::Lock => Some("Lock"),
                            Self::Unlock => Some("Unlock"),
                            Self::ReleaseContract => Some("ReleaseContract"),
                            _ => None,
                        }
                    }
                }
                impl core::fmt::Debug for EventType {
                    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                        if let Some(name) = self.variant_name() {
                            f.write_str(name)
                        } else {
                            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                        }
                    }
                }
                impl<'a> flatbuffers::Follow<'a> for EventType {
                    type Inner = Self;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                        Self(b)
                    }
                }

                impl flatbuffers::Push for EventType {
                    type Output = EventType;
                    #[inline]
                    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                        flatbuffers::emplace_scalar::<i8>(dst, self.0);
                    }
                }

                impl flatbuffers::EndianScalar for EventType {
                    type Scalar = i8;
                    #[inline]
                    fn to_little_endian(self) -> i8 {
                        self.0.to_le()
                    }
                    #[inline]
                    #[allow(clippy::wrong_self_convention)]
                    fn from_little_endian(v: i8) -> Self {
                        let b = i8::from_le(v);
                        Self(b)
                    }
                }

                impl<'a> flatbuffers::Verifiable for EventType {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        i8::run_verifier(v, pos)
                    }
                }

                impl flatbuffers::SimpleToVerifyInSlice for EventType {}
                pub enum CommonMetadataOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct CommonMetadata<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for CommonMetadata<'a> {
                    type Inner = CommonMetadata<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> CommonMetadata<'a> {
                    pub const VT_LOCK_SESSION: flatbuffers::VOffsetT = 4;
                    pub const VT_CONTRACT_SERIAL_NUMBER: flatbuffers::VOffsetT = 6;
                    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 8;
                    pub const VT_COUNTER: flatbuffers::VOffsetT = 10;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        CommonMetadata { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args CommonMetadataArgs<'args>,
                    ) -> flatbuffers::WIPOffset<CommonMetadata<'bldr>> {
                        let mut builder = CommonMetadataBuilder::new(_fbb);
                        if let Some(x) = args.lock_session {
                            builder.add_lock_session(x);
                        }
                        builder.add_counter(args.counter);
                        builder.add_serial_number(args.serial_number);
                        builder.add_contract_serial_number(args.contract_serial_number);
                        builder.finish()
                    }

                    #[inline]
                    pub fn lock_session(&self) -> Option<&'a str> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                                CommonMetadata::VT_LOCK_SESSION,
                                None,
                            )
                        }
                    }
                    #[inline]
                    pub fn contract_serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(CommonMetadata::VT_CONTRACT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(CommonMetadata::VT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn counter(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(CommonMetadata::VT_COUNTER, Some(0))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for CommonMetadata<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                                "lock_session",
                                Self::VT_LOCK_SESSION,
                                false,
                            )?
                            .visit_field::<u16>(
                                "contract_serial_number",
                                Self::VT_CONTRACT_SERIAL_NUMBER,
                                false,
                            )?
                            .visit_field::<u16>("serial_number", Self::VT_SERIAL_NUMBER, false)?
                            .visit_field::<u16>("counter", Self::VT_COUNTER, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct CommonMetadataArgs<'a> {
                    pub lock_session: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub contract_serial_number: u16,
                    pub serial_number: u16,
                    pub counter: u16,
                }
                impl<'a> Default for CommonMetadataArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        CommonMetadataArgs {
                            lock_session: None,
                            contract_serial_number: 0,
                            serial_number: 0,
                            counter: 0,
                        }
                    }
                }

                pub struct CommonMetadataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CommonMetadataBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_lock_session(
                        &mut self,
                        lock_session: flatbuffers::WIPOffset<&'b str>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            CommonMetadata::VT_LOCK_SESSION,
                            lock_session,
                        );
                    }
                    #[inline]
                    pub fn add_contract_serial_number(&mut self, contract_serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            CommonMetadata::VT_CONTRACT_SERIAL_NUMBER,
                            contract_serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_serial_number(&mut self, serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            CommonMetadata::VT_SERIAL_NUMBER,
                            serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_counter(&mut self, counter: u16) {
                        self.fbb_
                            .push_slot::<u16>(CommonMetadata::VT_COUNTER, counter, 0);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> CommonMetadataBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        CommonMetadataBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<CommonMetadata<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for CommonMetadata<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("CommonMetadata");
                        ds.field("lock_session", &self.lock_session());
                        ds.field("contract_serial_number", &self.contract_serial_number());
                        ds.field("serial_number", &self.serial_number());
                        ds.field("counter", &self.counter());
                        ds.finish()
                    }
                }
                pub enum EventOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Event<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Event<'a> {
                    type Inner = Event<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> Event<'a> {
                    pub const VT_METADATA: flatbuffers::VOffsetT = 4;
                    pub const VT_EVENT_TYPE: flatbuffers::VOffsetT = 6;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Event { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args EventArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Event<'bldr>> {
                        let mut builder = EventBuilder::new(_fbb);
                        if let Some(x) = args.metadata {
                            builder.add_metadata(x);
                        }
                        builder.add_event_type(args.event_type);
                        builder.finish()
                    }

                    #[inline]
                    pub fn metadata(&self) -> Option<CommonMetadata<'a>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<CommonMetadata>>(
                                    Event::VT_METADATA,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn event_type(&self) -> EventType {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<EventType>(Event::VT_EVENT_TYPE, Some(EventType::Undefined))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for Event<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<CommonMetadata>>(
                                "metadata",
                                Self::VT_METADATA,
                                false,
                            )?
                            .visit_field::<EventType>("event_type", Self::VT_EVENT_TYPE, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct EventArgs<'a> {
                    pub metadata: Option<flatbuffers::WIPOffset<CommonMetadata<'a>>>,
                    pub event_type: EventType,
                }
                impl<'a> Default for EventArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        EventArgs {
                            metadata: None,
                            event_type: EventType::Undefined,
                        }
                    }
                }

                pub struct EventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EventBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_metadata(
                        &mut self,
                        metadata: flatbuffers::WIPOffset<CommonMetadata<'b>>,
                    ) {
                        self.fbb_
                            .push_slot_always::<flatbuffers::WIPOffset<CommonMetadata>>(
                                Event::VT_METADATA,
                                metadata,
                            );
                    }
                    #[inline]
                    pub fn add_event_type(&mut self, event_type: EventType) {
                        self.fbb_.push_slot::<EventType>(
                            Event::VT_EVENT_TYPE,
                            event_type,
                            EventType::Undefined,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> EventBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        EventBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Event<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for Event<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("Event");
                        ds.field("metadata", &self.metadata());
                        ds.field("event_type", &self.event_type());
                        ds.finish()
                    }
                }
                pub enum SignedEventOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct SignedEvent<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for SignedEvent<'a> {
                    type Inner = SignedEvent<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> SignedEvent<'a> {
                    pub const VT_SIGNATURE: flatbuffers::VOffsetT = 4;
                    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        SignedEvent { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args SignedEventArgs<'args>,
                    ) -> flatbuffers::WIPOffset<SignedEvent<'bldr>> {
                        let mut builder = SignedEventBuilder::new(_fbb);
                        if let Some(x) = args.payload {
                            builder.add_payload(x);
                        }
                        if let Some(x) = args.signature {
                            builder.add_signature(x);
                        }
                        builder.finish()
                    }

                    #[inline]
                    pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                    SignedEvent::VT_SIGNATURE,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn payload(&self) -> Option<Event<'a>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab.get::<flatbuffers::ForwardsUOffset<Event>>(
                                SignedEvent::VT_PAYLOAD,
                                None,
                            )
                        }
                    }
                }

                impl flatbuffers::Verifiable for SignedEvent<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("signature", Self::VT_SIGNATURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Event>>("payload", Self::VT_PAYLOAD, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct SignedEventArgs<'a> {
                    pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    pub payload: Option<flatbuffers::WIPOffset<Event<'a>>>,
                }
                impl<'a> Default for SignedEventArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        SignedEventArgs {
                            signature: None,
                            payload: None,
                        }
                    }
                }

                pub struct SignedEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SignedEventBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_signature(
                        &mut self,
                        signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            SignedEvent::VT_SIGNATURE,
                            signature,
                        );
                    }
                    #[inline]
                    pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<Event<'b>>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Event>>(
                            SignedEvent::VT_PAYLOAD,
                            payload,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> SignedEventBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        SignedEventBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<SignedEvent<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for SignedEvent<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("SignedEvent");
                        ds.field("signature", &self.signature());
                        ds.field("payload", &self.payload());
                        ds.finish()
                    }
                }
                #[inline]
                /// Verifies that a buffer of bytes contains a `SignedEvent`
                /// and returns it.
                /// Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `root_as_signed_event_unchecked`.
                pub fn root_as_signed_event(
                    buf: &[u8],
                ) -> Result<SignedEvent, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::root::<SignedEvent>(buf)
                }
                #[inline]
                /// Verifies that a buffer of bytes contains a size prefixed
                /// `SignedEvent` and returns it.
                /// Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `size_prefixed_root_as_signed_event_unchecked`.
                pub fn size_prefixed_root_as_signed_event(
                    buf: &[u8],
                ) -> Result<SignedEvent, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::size_prefixed_root::<SignedEvent>(buf)
                }
                #[inline]
                /// Verifies, with the given options, that a buffer of bytes
                /// contains a `SignedEvent` and returns it.
                /// Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `root_as_signed_event_unchecked`.
                pub fn root_as_signed_event_with_opts<'b, 'o>(
                    opts: &'o flatbuffers::VerifierOptions,
                    buf: &'b [u8],
                ) -> Result<SignedEvent<'b>, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::root_with_opts::<SignedEvent<'b>>(opts, buf)
                }
                #[inline]
                /// Verifies, with the given verifier options, that a buffer of
                /// bytes contains a size prefixed `SignedEvent` and returns
                /// it. Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `root_as_signed_event_unchecked`.
                pub fn size_prefixed_root_as_signed_event_with_opts<'b, 'o>(
                    opts: &'o flatbuffers::VerifierOptions,
                    buf: &'b [u8],
                ) -> Result<SignedEvent<'b>, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::size_prefixed_root_with_opts::<SignedEvent<'b>>(opts, buf)
                }
                #[inline]
                /// Assumes, without verification, that a buffer of bytes contains a SignedEvent and returns it.
                /// # Safety
                /// Callers must trust the given bytes do indeed contain a valid `SignedEvent`.
                pub unsafe fn root_as_signed_event_unchecked(buf: &[u8]) -> SignedEvent {
                    flatbuffers::root_unchecked::<SignedEvent>(buf)
                }
                #[inline]
                /// Assumes, without verification, that a buffer of bytes contains a size prefixed SignedEvent and returns it.
                /// # Safety
                /// Callers must trust the given bytes do indeed contain a valid size prefixed `SignedEvent`.
                pub unsafe fn size_prefixed_root_as_signed_event_unchecked(
                    buf: &[u8],
                ) -> SignedEvent {
                    flatbuffers::size_prefixed_root_unchecked::<SignedEvent>(buf)
                }
                #[inline]
                pub fn finish_signed_event_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
                    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    root: flatbuffers::WIPOffset<SignedEvent<'a>>,
                ) {
                    fbb.finish(root, None);
                }

                #[inline]
                pub fn finish_size_prefixed_signed_event_buffer<
                    'a,
                    'b,
                    A: flatbuffers::Allocator + 'a,
                >(
                    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    root: flatbuffers::WIPOffset<SignedEvent<'a>>,
                ) {
                    fbb.finish_size_prefixed(root, None);
                }
            } // pub mod event
        } // pub mod fb
    } // pub mod subjugated
} // pub mod club
