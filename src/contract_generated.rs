// automatically generated by the FlatBuffers compiler, do not modify

// @generated
#![allow(clippy::all)]

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod club {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod subjugated {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};
        #[allow(unused_imports, dead_code)]
        pub mod fb {

            use core::cmp::Ordering;
            use core::mem;

            extern crate flatbuffers;
            use self::flatbuffers::{EndianScalar, Follow};
            #[allow(unused_imports, dead_code)]
            pub mod message {

                use core::cmp::Ordering;
                use core::mem;

                extern crate flatbuffers;
                use self::flatbuffers::{EndianScalar, Follow};

                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MIN_MESSAGE_PAYLOAD: u8 = 0;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MAX_MESSAGE_PAYLOAD: u8 = 9;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                #[allow(non_camel_case_types)]
                pub const ENUM_VALUES_MESSAGE_PAYLOAD: [MessagePayload; 10] = [
                    MessagePayload::NONE,
                    MessagePayload::Contract,
                    MessagePayload::LockCommand,
                    MessagePayload::UnlockCommand,
                    MessagePayload::ReleaseCommand,
                    MessagePayload::StartedUpdate,
                    MessagePayload::PeriodicUpdate,
                    MessagePayload::Acknowledgement,
                    MessagePayload::Error,
                    MessagePayload::AbortCommand,
                ];

                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
                #[repr(transparent)]
                pub struct MessagePayload(pub u8);
                #[allow(non_upper_case_globals)]
                impl MessagePayload {
                    pub const NONE: Self = Self(0);
                    pub const Contract: Self = Self(1);
                    pub const LockCommand: Self = Self(2);
                    pub const UnlockCommand: Self = Self(3);
                    pub const ReleaseCommand: Self = Self(4);
                    pub const StartedUpdate: Self = Self(5);
                    pub const PeriodicUpdate: Self = Self(6);
                    pub const Acknowledgement: Self = Self(7);
                    pub const Error: Self = Self(8);
                    pub const AbortCommand: Self = Self(9);

                    pub const ENUM_MIN: u8 = 0;
                    pub const ENUM_MAX: u8 = 9;
                    pub const ENUM_VALUES: &'static [Self] = &[
                        Self::NONE,
                        Self::Contract,
                        Self::LockCommand,
                        Self::UnlockCommand,
                        Self::ReleaseCommand,
                        Self::StartedUpdate,
                        Self::PeriodicUpdate,
                        Self::Acknowledgement,
                        Self::Error,
                        Self::AbortCommand,
                    ];
                    /// Returns the variant's name or "" if unknown.
                    pub fn variant_name(self) -> Option<&'static str> {
                        match self {
                            Self::NONE => Some("NONE"),
                            Self::Contract => Some("Contract"),
                            Self::LockCommand => Some("LockCommand"),
                            Self::UnlockCommand => Some("UnlockCommand"),
                            Self::ReleaseCommand => Some("ReleaseCommand"),
                            Self::StartedUpdate => Some("StartedUpdate"),
                            Self::PeriodicUpdate => Some("PeriodicUpdate"),
                            Self::Acknowledgement => Some("Acknowledgement"),
                            Self::Error => Some("Error"),
                            Self::AbortCommand => Some("AbortCommand"),
                            _ => None,
                        }
                    }
                }
                impl core::fmt::Debug for MessagePayload {
                    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                        if let Some(name) = self.variant_name() {
                            f.write_str(name)
                        } else {
                            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                        }
                    }
                }
                impl<'a> flatbuffers::Follow<'a> for MessagePayload {
                    type Inner = Self;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                        Self(b)
                    }
                }

                impl flatbuffers::Push for MessagePayload {
                    type Output = MessagePayload;
                    #[inline]
                    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                        flatbuffers::emplace_scalar::<u8>(dst, self.0);
                    }
                }

                impl flatbuffers::EndianScalar for MessagePayload {
                    type Scalar = u8;
                    #[inline]
                    fn to_little_endian(self) -> u8 {
                        self.0.to_le()
                    }
                    #[inline]
                    #[allow(clippy::wrong_self_convention)]
                    fn from_little_endian(v: u8) -> Self {
                        let b = u8::from_le(v);
                        Self(b)
                    }
                }

                impl<'a> flatbuffers::Verifiable for MessagePayload {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        u8::run_verifier(v, pos)
                    }
                }

                impl flatbuffers::SimpleToVerifyInSlice for MessagePayload {}
                pub struct MessagePayloadUnionTableOffset {}

                pub enum PermissionOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Permission<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Permission<'a> {
                    type Inner = Permission<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> Permission<'a> {
                    pub const VT_RECEIVE_EVENTS: flatbuffers::VOffsetT = 4;
                    pub const VT_CAN_UNLOCK: flatbuffers::VOffsetT = 6;
                    pub const VT_CAN_LOCK: flatbuffers::VOffsetT = 8;
                    pub const VT_CAN_RELEASE: flatbuffers::VOffsetT = 10;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Permission { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args PermissionArgs,
                    ) -> flatbuffers::WIPOffset<Permission<'bldr>> {
                        let mut builder = PermissionBuilder::new(_fbb);
                        builder.add_can_release(args.can_release);
                        builder.add_can_lock(args.can_lock);
                        builder.add_can_unlock(args.can_unlock);
                        builder.add_receive_events(args.receive_events);
                        builder.finish()
                    }

                    #[inline]
                    pub fn receive_events(&self) -> bool {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<bool>(Permission::VT_RECEIVE_EVENTS, Some(false))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn can_unlock(&self) -> bool {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<bool>(Permission::VT_CAN_UNLOCK, Some(false))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn can_lock(&self) -> bool {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<bool>(Permission::VT_CAN_LOCK, Some(false))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn can_release(&self) -> bool {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<bool>(Permission::VT_CAN_RELEASE, Some(false))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for Permission<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<bool>("receive_events", Self::VT_RECEIVE_EVENTS, false)?
                            .visit_field::<bool>("can_unlock", Self::VT_CAN_UNLOCK, false)?
                            .visit_field::<bool>("can_lock", Self::VT_CAN_LOCK, false)?
                            .visit_field::<bool>("can_release", Self::VT_CAN_RELEASE, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct PermissionArgs {
                    pub receive_events: bool,
                    pub can_unlock: bool,
                    pub can_lock: bool,
                    pub can_release: bool,
                }
                impl<'a> Default for PermissionArgs {
                    #[inline]
                    fn default() -> Self {
                        PermissionArgs {
                            receive_events: false,
                            can_unlock: false,
                            can_lock: false,
                            can_release: false,
                        }
                    }
                }

                pub struct PermissionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PermissionBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_receive_events(&mut self, receive_events: bool) {
                        self.fbb_.push_slot::<bool>(
                            Permission::VT_RECEIVE_EVENTS,
                            receive_events,
                            false,
                        );
                    }
                    #[inline]
                    pub fn add_can_unlock(&mut self, can_unlock: bool) {
                        self.fbb_
                            .push_slot::<bool>(Permission::VT_CAN_UNLOCK, can_unlock, false);
                    }
                    #[inline]
                    pub fn add_can_lock(&mut self, can_lock: bool) {
                        self.fbb_
                            .push_slot::<bool>(Permission::VT_CAN_LOCK, can_lock, false);
                    }
                    #[inline]
                    pub fn add_can_release(&mut self, can_release: bool) {
                        self.fbb_
                            .push_slot::<bool>(Permission::VT_CAN_RELEASE, can_release, false);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> PermissionBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        PermissionBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Permission<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for Permission<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("Permission");
                        ds.field("receive_events", &self.receive_events());
                        ds.field("can_unlock", &self.can_unlock());
                        ds.field("can_lock", &self.can_lock());
                        ds.field("can_release", &self.can_release());
                        ds.finish()
                    }
                }
                pub enum BotOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Bot<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Bot<'a> {
                    type Inner = Bot<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> Bot<'a> {
                    pub const VT_NAME: flatbuffers::VOffsetT = 4;
                    pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 6;
                    pub const VT_PERMISSIONS: flatbuffers::VOffsetT = 8;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Bot { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args BotArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Bot<'bldr>> {
                        let mut builder = BotBuilder::new(_fbb);
                        if let Some(x) = args.permissions {
                            builder.add_permissions(x);
                        }
                        if let Some(x) = args.public_key {
                            builder.add_public_key(x);
                        }
                        if let Some(x) = args.name {
                            builder.add_name(x);
                        }
                        builder.finish()
                    }

                    #[inline]
                    pub fn name(&self) -> Option<&'a str> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<&str>>(Bot::VT_NAME, None)
                        }
                    }
                    #[inline]
                    pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                    Bot::VT_PUBLIC_KEY,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn permissions(&self) -> Option<Permission<'a>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab.get::<flatbuffers::ForwardsUOffset<Permission>>(
                                Bot::VT_PERMISSIONS,
                                None,
                            )
                        }
                    }
                }

                impl flatbuffers::Verifiable for Bot<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Permission>>("permissions", Self::VT_PERMISSIONS, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct BotArgs<'a> {
                    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    pub permissions: Option<flatbuffers::WIPOffset<Permission<'a>>>,
                }
                impl<'a> Default for BotArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        BotArgs {
                            name: None,
                            public_key: None,
                            permissions: None,
                        }
                    }
                }

                pub struct BotBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BotBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_
                            .push_slot_always::<flatbuffers::WIPOffset<_>>(Bot::VT_NAME, name);
                    }
                    #[inline]
                    pub fn add_public_key(
                        &mut self,
                        public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Bot::VT_PUBLIC_KEY,
                            public_key,
                        );
                    }
                    #[inline]
                    pub fn add_permissions(
                        &mut self,
                        permissions: flatbuffers::WIPOffset<Permission<'b>>,
                    ) {
                        self.fbb_
                            .push_slot_always::<flatbuffers::WIPOffset<Permission>>(
                                Bot::VT_PERMISSIONS,
                                permissions,
                            );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> BotBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        BotBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Bot<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for Bot<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("Bot");
                        ds.field("name", &self.name());
                        ds.field("public_key", &self.public_key());
                        ds.field("permissions", &self.permissions());
                        ds.finish()
                    }
                }
                pub enum ContractOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Contract<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Contract<'a> {
                    type Inner = Contract<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> Contract<'a> {
                    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 4;
                    pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 6;
                    pub const VT_BOTS: flatbuffers::VOffsetT = 8;
                    pub const VT_TERMS: flatbuffers::VOffsetT = 10;
                    pub const VT_IS_TEMPORARY_UNLOCK_ALLOWED: flatbuffers::VOffsetT = 12;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Contract { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args ContractArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Contract<'bldr>> {
                        let mut builder = ContractBuilder::new(_fbb);
                        if let Some(x) = args.terms {
                            builder.add_terms(x);
                        }
                        if let Some(x) = args.bots {
                            builder.add_bots(x);
                        }
                        if let Some(x) = args.public_key {
                            builder.add_public_key(x);
                        }
                        builder.add_serial_number(args.serial_number);
                        builder.add_is_temporary_unlock_allowed(args.is_temporary_unlock_allowed);
                        builder.finish()
                    }

                    #[inline]
                    pub fn serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(Contract::VT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                    Contract::VT_PUBLIC_KEY,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn bots(
                        &self,
                    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bot<'a>>>>
                    {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab.get::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bot>>,
                            >>(Contract::VT_BOTS, None)
                        }
                    }
                    #[inline]
                    pub fn terms(&self) -> Option<&'a str> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<&str>>(Contract::VT_TERMS, None)
                        }
                    }
                    #[inline]
                    pub fn is_temporary_unlock_allowed(&self) -> bool {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<bool>(Contract::VT_IS_TEMPORARY_UNLOCK_ALLOWED, Some(false))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for Contract<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<u16>("serial_number", Self::VT_SERIAL_NUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Bot>>>>("bots", Self::VT_BOTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("terms", Self::VT_TERMS, false)?
     .visit_field::<bool>("is_temporary_unlock_allowed", Self::VT_IS_TEMPORARY_UNLOCK_ALLOWED, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct ContractArgs<'a> {
                    pub serial_number: u16,
                    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    pub bots: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bot<'a>>>,
                        >,
                    >,
                    pub terms: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub is_temporary_unlock_allowed: bool,
                }
                impl<'a> Default for ContractArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        ContractArgs {
                            serial_number: 0,
                            public_key: None,
                            bots: None,
                            terms: None,
                            is_temporary_unlock_allowed: false,
                        }
                    }
                }

                pub struct ContractBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContractBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_serial_number(&mut self, serial_number: u16) {
                        self.fbb_
                            .push_slot::<u16>(Contract::VT_SERIAL_NUMBER, serial_number, 0);
                    }
                    #[inline]
                    pub fn add_public_key(
                        &mut self,
                        public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Contract::VT_PUBLIC_KEY,
                            public_key,
                        );
                    }
                    #[inline]
                    pub fn add_bots(
                        &mut self,
                        bots: flatbuffers::WIPOffset<
                            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Bot<'b>>>,
                        >,
                    ) {
                        self.fbb_
                            .push_slot_always::<flatbuffers::WIPOffset<_>>(Contract::VT_BOTS, bots);
                    }
                    #[inline]
                    pub fn add_terms(&mut self, terms: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Contract::VT_TERMS,
                            terms,
                        );
                    }
                    #[inline]
                    pub fn add_is_temporary_unlock_allowed(
                        &mut self,
                        is_temporary_unlock_allowed: bool,
                    ) {
                        self.fbb_.push_slot::<bool>(
                            Contract::VT_IS_TEMPORARY_UNLOCK_ALLOWED,
                            is_temporary_unlock_allowed,
                            false,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> ContractBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        ContractBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Contract<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for Contract<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("Contract");
                        ds.field("serial_number", &self.serial_number());
                        ds.field("public_key", &self.public_key());
                        ds.field("bots", &self.bots());
                        ds.field("terms", &self.terms());
                        ds.field(
                            "is_temporary_unlock_allowed",
                            &self.is_temporary_unlock_allowed(),
                        );
                        ds.finish()
                    }
                }
                pub enum StartedUpdateOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct StartedUpdate<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for StartedUpdate<'a> {
                    type Inner = StartedUpdate<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> StartedUpdate<'a> {
                    pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
                    pub const VT_SESSION: flatbuffers::VOffsetT = 6;
                    pub const VT_STARTED_WITH_LOCAL_CONTRACT: flatbuffers::VOffsetT = 8;
                    pub const VT_CURRENT_CONTRACT_SERIAL: flatbuffers::VOffsetT = 10;
                    pub const VT_IS_LOCKED: flatbuffers::VOffsetT = 12;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        StartedUpdate { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args StartedUpdateArgs<'args>,
                    ) -> flatbuffers::WIPOffset<StartedUpdate<'bldr>> {
                        let mut builder = StartedUpdateBuilder::new(_fbb);
                        if let Some(x) = args.session {
                            builder.add_session(x);
                        }
                        if let Some(x) = args.public_key {
                            builder.add_public_key(x);
                        }
                        builder.add_current_contract_serial(args.current_contract_serial);
                        builder.add_is_locked(args.is_locked);
                        builder.add_started_with_local_contract(args.started_with_local_contract);
                        builder.finish()
                    }

                    #[inline]
                    pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                    StartedUpdate::VT_PUBLIC_KEY,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn session(&self) -> Option<&'a str> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                                StartedUpdate::VT_SESSION,
                                None,
                            )
                        }
                    }
                    #[inline]
                    pub fn started_with_local_contract(&self) -> bool {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<bool>(
                                    StartedUpdate::VT_STARTED_WITH_LOCAL_CONTRACT,
                                    Some(false),
                                )
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn current_contract_serial(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(StartedUpdate::VT_CURRENT_CONTRACT_SERIAL, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn is_locked(&self) -> bool {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<bool>(StartedUpdate::VT_IS_LOCKED, Some(false))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for StartedUpdate<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("session", Self::VT_SESSION, false)?
     .visit_field::<bool>("started_with_local_contract", Self::VT_STARTED_WITH_LOCAL_CONTRACT, false)?
     .visit_field::<u16>("current_contract_serial", Self::VT_CURRENT_CONTRACT_SERIAL, false)?
     .visit_field::<bool>("is_locked", Self::VT_IS_LOCKED, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct StartedUpdateArgs<'a> {
                    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    pub session: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub started_with_local_contract: bool,
                    pub current_contract_serial: u16,
                    pub is_locked: bool,
                }
                impl<'a> Default for StartedUpdateArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        StartedUpdateArgs {
                            public_key: None,
                            session: None,
                            started_with_local_contract: false,
                            current_contract_serial: 0,
                            is_locked: false,
                        }
                    }
                }

                pub struct StartedUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StartedUpdateBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_public_key(
                        &mut self,
                        public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            StartedUpdate::VT_PUBLIC_KEY,
                            public_key,
                        );
                    }
                    #[inline]
                    pub fn add_session(&mut self, session: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            StartedUpdate::VT_SESSION,
                            session,
                        );
                    }
                    #[inline]
                    pub fn add_started_with_local_contract(
                        &mut self,
                        started_with_local_contract: bool,
                    ) {
                        self.fbb_.push_slot::<bool>(
                            StartedUpdate::VT_STARTED_WITH_LOCAL_CONTRACT,
                            started_with_local_contract,
                            false,
                        );
                    }
                    #[inline]
                    pub fn add_current_contract_serial(&mut self, current_contract_serial: u16) {
                        self.fbb_.push_slot::<u16>(
                            StartedUpdate::VT_CURRENT_CONTRACT_SERIAL,
                            current_contract_serial,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_is_locked(&mut self, is_locked: bool) {
                        self.fbb_
                            .push_slot::<bool>(StartedUpdate::VT_IS_LOCKED, is_locked, false);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> StartedUpdateBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        StartedUpdateBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<StartedUpdate<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for StartedUpdate<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("StartedUpdate");
                        ds.field("public_key", &self.public_key());
                        ds.field("session", &self.session());
                        ds.field(
                            "started_with_local_contract",
                            &self.started_with_local_contract(),
                        );
                        ds.field("current_contract_serial", &self.current_contract_serial());
                        ds.field("is_locked", &self.is_locked());
                        ds.finish()
                    }
                }
                pub enum PeriodicUpdateOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct PeriodicUpdate<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for PeriodicUpdate<'a> {
                    type Inner = PeriodicUpdate<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> PeriodicUpdate<'a> {
                    pub const VT_SESSION: flatbuffers::VOffsetT = 4;
                    pub const VT_IS_LOCKED: flatbuffers::VOffsetT = 6;
                    pub const VT_CURRENT_CONTRACT_SERIAL: flatbuffers::VOffsetT = 8;
                    pub const VT_LOCAL_UNLOCK: flatbuffers::VOffsetT = 10;
                    pub const VT_LOCAL_LOCK: flatbuffers::VOffsetT = 12;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        PeriodicUpdate { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args PeriodicUpdateArgs<'args>,
                    ) -> flatbuffers::WIPOffset<PeriodicUpdate<'bldr>> {
                        let mut builder = PeriodicUpdateBuilder::new(_fbb);
                        if let Some(x) = args.session {
                            builder.add_session(x);
                        }
                        builder.add_current_contract_serial(args.current_contract_serial);
                        builder.add_local_lock(args.local_lock);
                        builder.add_local_unlock(args.local_unlock);
                        builder.add_is_locked(args.is_locked);
                        builder.finish()
                    }

                    #[inline]
                    pub fn session(&self) -> Option<&'a str> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                                PeriodicUpdate::VT_SESSION,
                                None,
                            )
                        }
                    }
                    #[inline]
                    pub fn is_locked(&self) -> bool {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<bool>(PeriodicUpdate::VT_IS_LOCKED, Some(false))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn current_contract_serial(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(PeriodicUpdate::VT_CURRENT_CONTRACT_SERIAL, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn local_unlock(&self) -> bool {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<bool>(PeriodicUpdate::VT_LOCAL_UNLOCK, Some(false))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn local_lock(&self) -> bool {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<bool>(PeriodicUpdate::VT_LOCAL_LOCK, Some(false))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for PeriodicUpdate<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                                "session",
                                Self::VT_SESSION,
                                false,
                            )?
                            .visit_field::<bool>("is_locked", Self::VT_IS_LOCKED, false)?
                            .visit_field::<u16>(
                                "current_contract_serial",
                                Self::VT_CURRENT_CONTRACT_SERIAL,
                                false,
                            )?
                            .visit_field::<bool>("local_unlock", Self::VT_LOCAL_UNLOCK, false)?
                            .visit_field::<bool>("local_lock", Self::VT_LOCAL_LOCK, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct PeriodicUpdateArgs<'a> {
                    pub session: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub is_locked: bool,
                    pub current_contract_serial: u16,
                    pub local_unlock: bool,
                    pub local_lock: bool,
                }
                impl<'a> Default for PeriodicUpdateArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        PeriodicUpdateArgs {
                            session: None,
                            is_locked: false,
                            current_contract_serial: 0,
                            local_unlock: false,
                            local_lock: false,
                        }
                    }
                }

                pub struct PeriodicUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PeriodicUpdateBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_session(&mut self, session: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            PeriodicUpdate::VT_SESSION,
                            session,
                        );
                    }
                    #[inline]
                    pub fn add_is_locked(&mut self, is_locked: bool) {
                        self.fbb_
                            .push_slot::<bool>(PeriodicUpdate::VT_IS_LOCKED, is_locked, false);
                    }
                    #[inline]
                    pub fn add_current_contract_serial(&mut self, current_contract_serial: u16) {
                        self.fbb_.push_slot::<u16>(
                            PeriodicUpdate::VT_CURRENT_CONTRACT_SERIAL,
                            current_contract_serial,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_local_unlock(&mut self, local_unlock: bool) {
                        self.fbb_.push_slot::<bool>(
                            PeriodicUpdate::VT_LOCAL_UNLOCK,
                            local_unlock,
                            false,
                        );
                    }
                    #[inline]
                    pub fn add_local_lock(&mut self, local_lock: bool) {
                        self.fbb_.push_slot::<bool>(
                            PeriodicUpdate::VT_LOCAL_LOCK,
                            local_lock,
                            false,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> PeriodicUpdateBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        PeriodicUpdateBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<PeriodicUpdate<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for PeriodicUpdate<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("PeriodicUpdate");
                        ds.field("session", &self.session());
                        ds.field("is_locked", &self.is_locked());
                        ds.field("current_contract_serial", &self.current_contract_serial());
                        ds.field("local_unlock", &self.local_unlock());
                        ds.field("local_lock", &self.local_lock());
                        ds.finish()
                    }
                }
                pub enum AcknowledgementOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Acknowledgement<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Acknowledgement<'a> {
                    type Inner = Acknowledgement<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> Acknowledgement<'a> {
                    pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
                    pub const VT_SESSION: flatbuffers::VOffsetT = 6;
                    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 8;
                    pub const VT_COUNTER: flatbuffers::VOffsetT = 10;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Acknowledgement { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args AcknowledgementArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Acknowledgement<'bldr>> {
                        let mut builder = AcknowledgementBuilder::new(_fbb);
                        if let Some(x) = args.session {
                            builder.add_session(x);
                        }
                        if let Some(x) = args.public_key {
                            builder.add_public_key(x);
                        }
                        builder.add_counter(args.counter);
                        builder.add_serial_number(args.serial_number);
                        builder.finish()
                    }

                    #[inline]
                    pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                    Acknowledgement::VT_PUBLIC_KEY,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn session(&self) -> Option<&'a str> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                                Acknowledgement::VT_SESSION,
                                None,
                            )
                        }
                    }
                    #[inline]
                    pub fn serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(Acknowledgement::VT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn counter(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(Acknowledgement::VT_COUNTER, Some(0))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for Acknowledgement<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("session", Self::VT_SESSION, false)?
     .visit_field::<u16>("serial_number", Self::VT_SERIAL_NUMBER, false)?
     .visit_field::<u16>("counter", Self::VT_COUNTER, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct AcknowledgementArgs<'a> {
                    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    pub session: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub serial_number: u16,
                    pub counter: u16,
                }
                impl<'a> Default for AcknowledgementArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        AcknowledgementArgs {
                            public_key: None,
                            session: None,
                            serial_number: 0,
                            counter: 0,
                        }
                    }
                }

                pub struct AcknowledgementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AcknowledgementBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_public_key(
                        &mut self,
                        public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Acknowledgement::VT_PUBLIC_KEY,
                            public_key,
                        );
                    }
                    #[inline]
                    pub fn add_session(&mut self, session: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Acknowledgement::VT_SESSION,
                            session,
                        );
                    }
                    #[inline]
                    pub fn add_serial_number(&mut self, serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            Acknowledgement::VT_SERIAL_NUMBER,
                            serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_counter(&mut self, counter: u16) {
                        self.fbb_
                            .push_slot::<u16>(Acknowledgement::VT_COUNTER, counter, 0);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> AcknowledgementBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        AcknowledgementBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Acknowledgement<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for Acknowledgement<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("Acknowledgement");
                        ds.field("public_key", &self.public_key());
                        ds.field("session", &self.session());
                        ds.field("serial_number", &self.serial_number());
                        ds.field("counter", &self.counter());
                        ds.finish()
                    }
                }
                pub enum ErrorOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Error<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Error<'a> {
                    type Inner = Error<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> Error<'a> {
                    pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
                    pub const VT_SESSION: flatbuffers::VOffsetT = 6;
                    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 8;
                    pub const VT_COUNTER: flatbuffers::VOffsetT = 10;
                    pub const VT_MESSAGE: flatbuffers::VOffsetT = 12;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Error { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args ErrorArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Error<'bldr>> {
                        let mut builder = ErrorBuilder::new(_fbb);
                        if let Some(x) = args.message {
                            builder.add_message(x);
                        }
                        if let Some(x) = args.session {
                            builder.add_session(x);
                        }
                        if let Some(x) = args.public_key {
                            builder.add_public_key(x);
                        }
                        builder.add_counter(args.counter);
                        builder.add_serial_number(args.serial_number);
                        builder.finish()
                    }

                    #[inline]
                    pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                    Error::VT_PUBLIC_KEY,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn session(&self) -> Option<&'a str> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<&str>>(Error::VT_SESSION, None)
                        }
                    }
                    #[inline]
                    pub fn serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(Error::VT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn counter(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe { self._tab.get::<u16>(Error::VT_COUNTER, Some(0)).unwrap() }
                    }
                    #[inline]
                    pub fn message(&self) -> Option<&'a str> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<&str>>(Error::VT_MESSAGE, None)
                        }
                    }
                }

                impl flatbuffers::Verifiable for Error<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("session", Self::VT_SESSION, false)?
     .visit_field::<u16>("serial_number", Self::VT_SERIAL_NUMBER, false)?
     .visit_field::<u16>("counter", Self::VT_COUNTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct ErrorArgs<'a> {
                    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    pub session: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub serial_number: u16,
                    pub counter: u16,
                    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
                }
                impl<'a> Default for ErrorArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        ErrorArgs {
                            public_key: None,
                            session: None,
                            serial_number: 0,
                            counter: 0,
                            message: None,
                        }
                    }
                }

                pub struct ErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ErrorBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_public_key(
                        &mut self,
                        public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Error::VT_PUBLIC_KEY,
                            public_key,
                        );
                    }
                    #[inline]
                    pub fn add_session(&mut self, session: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Error::VT_SESSION,
                            session,
                        );
                    }
                    #[inline]
                    pub fn add_serial_number(&mut self, serial_number: u16) {
                        self.fbb_
                            .push_slot::<u16>(Error::VT_SERIAL_NUMBER, serial_number, 0);
                    }
                    #[inline]
                    pub fn add_counter(&mut self, counter: u16) {
                        self.fbb_.push_slot::<u16>(Error::VT_COUNTER, counter, 0);
                    }
                    #[inline]
                    pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Error::VT_MESSAGE,
                            message,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> ErrorBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        ErrorBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Error<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for Error<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("Error");
                        ds.field("public_key", &self.public_key());
                        ds.field("session", &self.session());
                        ds.field("serial_number", &self.serial_number());
                        ds.field("counter", &self.counter());
                        ds.field("message", &self.message());
                        ds.finish()
                    }
                }
                pub enum LockCommandOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct LockCommand<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for LockCommand<'a> {
                    type Inner = LockCommand<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> LockCommand<'a> {
                    pub const VT_CONTRACT_SERIAL_NUMBER: flatbuffers::VOffsetT = 4;
                    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 6;
                    pub const VT_COUNTER: flatbuffers::VOffsetT = 8;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        LockCommand { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args LockCommandArgs,
                    ) -> flatbuffers::WIPOffset<LockCommand<'bldr>> {
                        let mut builder = LockCommandBuilder::new(_fbb);
                        builder.add_counter(args.counter);
                        builder.add_serial_number(args.serial_number);
                        builder.add_contract_serial_number(args.contract_serial_number);
                        builder.finish()
                    }

                    #[inline]
                    pub fn contract_serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(LockCommand::VT_CONTRACT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(LockCommand::VT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn counter(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(LockCommand::VT_COUNTER, Some(0))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for LockCommand<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<u16>(
                                "contract_serial_number",
                                Self::VT_CONTRACT_SERIAL_NUMBER,
                                false,
                            )?
                            .visit_field::<u16>("serial_number", Self::VT_SERIAL_NUMBER, false)?
                            .visit_field::<u16>("counter", Self::VT_COUNTER, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct LockCommandArgs {
                    pub contract_serial_number: u16,
                    pub serial_number: u16,
                    pub counter: u16,
                }
                impl<'a> Default for LockCommandArgs {
                    #[inline]
                    fn default() -> Self {
                        LockCommandArgs {
                            contract_serial_number: 0,
                            serial_number: 0,
                            counter: 0,
                        }
                    }
                }

                pub struct LockCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LockCommandBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_contract_serial_number(&mut self, contract_serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            LockCommand::VT_CONTRACT_SERIAL_NUMBER,
                            contract_serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_serial_number(&mut self, serial_number: u16) {
                        self.fbb_
                            .push_slot::<u16>(LockCommand::VT_SERIAL_NUMBER, serial_number, 0);
                    }
                    #[inline]
                    pub fn add_counter(&mut self, counter: u16) {
                        self.fbb_
                            .push_slot::<u16>(LockCommand::VT_COUNTER, counter, 0);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> LockCommandBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        LockCommandBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<LockCommand<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for LockCommand<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("LockCommand");
                        ds.field("contract_serial_number", &self.contract_serial_number());
                        ds.field("serial_number", &self.serial_number());
                        ds.field("counter", &self.counter());
                        ds.finish()
                    }
                }
                pub enum UnlockCommandOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct UnlockCommand<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for UnlockCommand<'a> {
                    type Inner = UnlockCommand<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> UnlockCommand<'a> {
                    pub const VT_CONTRACT_SERIAL_NUMBER: flatbuffers::VOffsetT = 4;
                    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 6;
                    pub const VT_COUNTER: flatbuffers::VOffsetT = 8;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        UnlockCommand { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args UnlockCommandArgs,
                    ) -> flatbuffers::WIPOffset<UnlockCommand<'bldr>> {
                        let mut builder = UnlockCommandBuilder::new(_fbb);
                        builder.add_counter(args.counter);
                        builder.add_serial_number(args.serial_number);
                        builder.add_contract_serial_number(args.contract_serial_number);
                        builder.finish()
                    }

                    #[inline]
                    pub fn contract_serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(UnlockCommand::VT_CONTRACT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(UnlockCommand::VT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn counter(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(UnlockCommand::VT_COUNTER, Some(0))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for UnlockCommand<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<u16>(
                                "contract_serial_number",
                                Self::VT_CONTRACT_SERIAL_NUMBER,
                                false,
                            )?
                            .visit_field::<u16>("serial_number", Self::VT_SERIAL_NUMBER, false)?
                            .visit_field::<u16>("counter", Self::VT_COUNTER, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct UnlockCommandArgs {
                    pub contract_serial_number: u16,
                    pub serial_number: u16,
                    pub counter: u16,
                }
                impl<'a> Default for UnlockCommandArgs {
                    #[inline]
                    fn default() -> Self {
                        UnlockCommandArgs {
                            contract_serial_number: 0,
                            serial_number: 0,
                            counter: 0,
                        }
                    }
                }

                pub struct UnlockCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnlockCommandBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_contract_serial_number(&mut self, contract_serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            UnlockCommand::VT_CONTRACT_SERIAL_NUMBER,
                            contract_serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_serial_number(&mut self, serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            UnlockCommand::VT_SERIAL_NUMBER,
                            serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_counter(&mut self, counter: u16) {
                        self.fbb_
                            .push_slot::<u16>(UnlockCommand::VT_COUNTER, counter, 0);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> UnlockCommandBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        UnlockCommandBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<UnlockCommand<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for UnlockCommand<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("UnlockCommand");
                        ds.field("contract_serial_number", &self.contract_serial_number());
                        ds.field("serial_number", &self.serial_number());
                        ds.field("counter", &self.counter());
                        ds.finish()
                    }
                }
                pub enum ReleaseCommandOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct ReleaseCommand<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for ReleaseCommand<'a> {
                    type Inner = ReleaseCommand<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> ReleaseCommand<'a> {
                    pub const VT_CONTRACT_SERIAL_NUMBER: flatbuffers::VOffsetT = 4;
                    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 6;
                    pub const VT_COUNTER: flatbuffers::VOffsetT = 8;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        ReleaseCommand { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args ReleaseCommandArgs,
                    ) -> flatbuffers::WIPOffset<ReleaseCommand<'bldr>> {
                        let mut builder = ReleaseCommandBuilder::new(_fbb);
                        builder.add_counter(args.counter);
                        builder.add_serial_number(args.serial_number);
                        builder.add_contract_serial_number(args.contract_serial_number);
                        builder.finish()
                    }

                    #[inline]
                    pub fn contract_serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(ReleaseCommand::VT_CONTRACT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(ReleaseCommand::VT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn counter(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(ReleaseCommand::VT_COUNTER, Some(0))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for ReleaseCommand<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<u16>(
                                "contract_serial_number",
                                Self::VT_CONTRACT_SERIAL_NUMBER,
                                false,
                            )?
                            .visit_field::<u16>("serial_number", Self::VT_SERIAL_NUMBER, false)?
                            .visit_field::<u16>("counter", Self::VT_COUNTER, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct ReleaseCommandArgs {
                    pub contract_serial_number: u16,
                    pub serial_number: u16,
                    pub counter: u16,
                }
                impl<'a> Default for ReleaseCommandArgs {
                    #[inline]
                    fn default() -> Self {
                        ReleaseCommandArgs {
                            contract_serial_number: 0,
                            serial_number: 0,
                            counter: 0,
                        }
                    }
                }

                pub struct ReleaseCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReleaseCommandBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_contract_serial_number(&mut self, contract_serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            ReleaseCommand::VT_CONTRACT_SERIAL_NUMBER,
                            contract_serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_serial_number(&mut self, serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            ReleaseCommand::VT_SERIAL_NUMBER,
                            serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_counter(&mut self, counter: u16) {
                        self.fbb_
                            .push_slot::<u16>(ReleaseCommand::VT_COUNTER, counter, 0);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> ReleaseCommandBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        ReleaseCommandBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<ReleaseCommand<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for ReleaseCommand<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("ReleaseCommand");
                        ds.field("contract_serial_number", &self.contract_serial_number());
                        ds.field("serial_number", &self.serial_number());
                        ds.field("counter", &self.counter());
                        ds.finish()
                    }
                }
                pub enum AbortCommandOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct AbortCommand<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for AbortCommand<'a> {
                    type Inner = AbortCommand<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> AbortCommand<'a> {
                    pub const VT_CONTRACT_SERIAL_NUMBER: flatbuffers::VOffsetT = 4;
                    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 6;
                    pub const VT_COUNTER: flatbuffers::VOffsetT = 8;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        AbortCommand { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args AbortCommandArgs,
                    ) -> flatbuffers::WIPOffset<AbortCommand<'bldr>> {
                        let mut builder = AbortCommandBuilder::new(_fbb);
                        builder.add_counter(args.counter);
                        builder.add_serial_number(args.serial_number);
                        builder.add_contract_serial_number(args.contract_serial_number);
                        builder.finish()
                    }

                    #[inline]
                    pub fn contract_serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(AbortCommand::VT_CONTRACT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(AbortCommand::VT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn counter(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(AbortCommand::VT_COUNTER, Some(0))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for AbortCommand<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<u16>(
                                "contract_serial_number",
                                Self::VT_CONTRACT_SERIAL_NUMBER,
                                false,
                            )?
                            .visit_field::<u16>("serial_number", Self::VT_SERIAL_NUMBER, false)?
                            .visit_field::<u16>("counter", Self::VT_COUNTER, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct AbortCommandArgs {
                    pub contract_serial_number: u16,
                    pub serial_number: u16,
                    pub counter: u16,
                }
                impl<'a> Default for AbortCommandArgs {
                    #[inline]
                    fn default() -> Self {
                        AbortCommandArgs {
                            contract_serial_number: 0,
                            serial_number: 0,
                            counter: 0,
                        }
                    }
                }

                pub struct AbortCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AbortCommandBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_contract_serial_number(&mut self, contract_serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            AbortCommand::VT_CONTRACT_SERIAL_NUMBER,
                            contract_serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_serial_number(&mut self, serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            AbortCommand::VT_SERIAL_NUMBER,
                            serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_counter(&mut self, counter: u16) {
                        self.fbb_
                            .push_slot::<u16>(AbortCommand::VT_COUNTER, counter, 0);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> AbortCommandBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        AbortCommandBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<AbortCommand<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for AbortCommand<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("AbortCommand");
                        ds.field("contract_serial_number", &self.contract_serial_number());
                        ds.field("serial_number", &self.serial_number());
                        ds.field("counter", &self.counter());
                        ds.finish()
                    }
                }
                pub enum SignedMessageOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct SignedMessage<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for SignedMessage<'a> {
                    type Inner = SignedMessage<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> SignedMessage<'a> {
                    pub const VT_SIGNATURE: flatbuffers::VOffsetT = 4;
                    pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 6;
                    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 8;
                    pub const VT_AUTHORITY_IDENTIFIER: flatbuffers::VOffsetT = 10;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        SignedMessage { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args SignedMessageArgs<'args>,
                    ) -> flatbuffers::WIPOffset<SignedMessage<'bldr>> {
                        let mut builder = SignedMessageBuilder::new(_fbb);
                        if let Some(x) = args.authority_identifier {
                            builder.add_authority_identifier(x);
                        }
                        if let Some(x) = args.payload {
                            builder.add_payload(x);
                        }
                        if let Some(x) = args.signature {
                            builder.add_signature(x);
                        }
                        builder.add_payload_type(args.payload_type);
                        builder.finish()
                    }

                    #[inline]
                    pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                    SignedMessage::VT_SIGNATURE,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn payload_type(&self) -> MessagePayload {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<MessagePayload>(
                                    SignedMessage::VT_PAYLOAD_TYPE,
                                    Some(MessagePayload::NONE),
                                )
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                                    SignedMessage::VT_PAYLOAD,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn authority_identifier(&self) -> Option<&'a str> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                                SignedMessage::VT_AUTHORITY_IDENTIFIER,
                                None,
                            )
                        }
                    }
                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_contract(&self) -> Option<Contract<'a>> {
                        if self.payload_type() == MessagePayload::Contract {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { Contract::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_lock_command(&self) -> Option<LockCommand<'a>> {
                        if self.payload_type() == MessagePayload::LockCommand {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { LockCommand::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_unlock_command(&self) -> Option<UnlockCommand<'a>> {
                        if self.payload_type() == MessagePayload::UnlockCommand {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { UnlockCommand::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_release_command(&self) -> Option<ReleaseCommand<'a>> {
                        if self.payload_type() == MessagePayload::ReleaseCommand {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { ReleaseCommand::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_started_update(&self) -> Option<StartedUpdate<'a>> {
                        if self.payload_type() == MessagePayload::StartedUpdate {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { StartedUpdate::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_periodic_update(&self) -> Option<PeriodicUpdate<'a>> {
                        if self.payload_type() == MessagePayload::PeriodicUpdate {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { PeriodicUpdate::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_acknowledgement(&self) -> Option<Acknowledgement<'a>> {
                        if self.payload_type() == MessagePayload::Acknowledgement {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { Acknowledgement::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_error(&self) -> Option<Error<'a>> {
                        if self.payload_type() == MessagePayload::Error {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { Error::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_abort_command(&self) -> Option<AbortCommand<'a>> {
                        if self.payload_type() == MessagePayload::AbortCommand {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { AbortCommand::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }
                }

                impl flatbuffers::Verifiable for SignedMessage<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("signature", Self::VT_SIGNATURE, false)?
     .visit_union::<MessagePayload, _>("payload_type", Self::VT_PAYLOAD_TYPE, "payload", Self::VT_PAYLOAD, false, |key, v, pos| {
        match key {
          MessagePayload::Contract => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Contract>>("MessagePayload::Contract", pos),
          MessagePayload::LockCommand => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LockCommand>>("MessagePayload::LockCommand", pos),
          MessagePayload::UnlockCommand => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnlockCommand>>("MessagePayload::UnlockCommand", pos),
          MessagePayload::ReleaseCommand => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReleaseCommand>>("MessagePayload::ReleaseCommand", pos),
          MessagePayload::StartedUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StartedUpdate>>("MessagePayload::StartedUpdate", pos),
          MessagePayload::PeriodicUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PeriodicUpdate>>("MessagePayload::PeriodicUpdate", pos),
          MessagePayload::Acknowledgement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Acknowledgement>>("MessagePayload::Acknowledgement", pos),
          MessagePayload::Error => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Error>>("MessagePayload::Error", pos),
          MessagePayload::AbortCommand => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AbortCommand>>("MessagePayload::AbortCommand", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("authority_identifier", Self::VT_AUTHORITY_IDENTIFIER, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct SignedMessageArgs<'a> {
                    pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    pub payload_type: MessagePayload,
                    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
                    pub authority_identifier: Option<flatbuffers::WIPOffset<&'a str>>,
                }
                impl<'a> Default for SignedMessageArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        SignedMessageArgs {
                            signature: None,
                            payload_type: MessagePayload::NONE,
                            payload: None,
                            authority_identifier: None,
                        }
                    }
                }

                pub struct SignedMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SignedMessageBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_signature(
                        &mut self,
                        signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            SignedMessage::VT_SIGNATURE,
                            signature,
                        );
                    }
                    #[inline]
                    pub fn add_payload_type(&mut self, payload_type: MessagePayload) {
                        self.fbb_.push_slot::<MessagePayload>(
                            SignedMessage::VT_PAYLOAD_TYPE,
                            payload_type,
                            MessagePayload::NONE,
                        );
                    }
                    #[inline]
                    pub fn add_payload(
                        &mut self,
                        payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            SignedMessage::VT_PAYLOAD,
                            payload,
                        );
                    }
                    #[inline]
                    pub fn add_authority_identifier(
                        &mut self,
                        authority_identifier: flatbuffers::WIPOffset<&'b str>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            SignedMessage::VT_AUTHORITY_IDENTIFIER,
                            authority_identifier,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> SignedMessageBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        SignedMessageBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<SignedMessage<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for SignedMessage<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("SignedMessage");
                        ds.field("signature", &self.signature());
                        ds.field("payload_type", &self.payload_type());
                        match self.payload_type() {
                            MessagePayload::Contract => {
                                if let Some(x) = self.payload_as_contract() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::LockCommand => {
                                if let Some(x) = self.payload_as_lock_command() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::UnlockCommand => {
                                if let Some(x) = self.payload_as_unlock_command() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::ReleaseCommand => {
                                if let Some(x) = self.payload_as_release_command() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::StartedUpdate => {
                                if let Some(x) = self.payload_as_started_update() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::PeriodicUpdate => {
                                if let Some(x) = self.payload_as_periodic_update() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::Acknowledgement => {
                                if let Some(x) = self.payload_as_acknowledgement() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::Error => {
                                if let Some(x) = self.payload_as_error() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::AbortCommand => {
                                if let Some(x) = self.payload_as_abort_command() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            _ => {
                                let x: Option<()> = None;
                                ds.field("payload", &x)
                            }
                        };
                        ds.field("authority_identifier", &self.authority_identifier());
                        ds.finish()
                    }
                }
                #[inline]
                /// Verifies that a buffer of bytes contains a `SignedMessage`
                /// and returns it.
                /// Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `root_as_signed_message_unchecked`.
                pub fn root_as_signed_message(
                    buf: &[u8],
                ) -> Result<SignedMessage, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::root::<SignedMessage>(buf)
                }
                #[inline]
                /// Verifies that a buffer of bytes contains a size prefixed
                /// `SignedMessage` and returns it.
                /// Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `size_prefixed_root_as_signed_message_unchecked`.
                pub fn size_prefixed_root_as_signed_message(
                    buf: &[u8],
                ) -> Result<SignedMessage, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::size_prefixed_root::<SignedMessage>(buf)
                }
                #[inline]
                /// Verifies, with the given options, that a buffer of bytes
                /// contains a `SignedMessage` and returns it.
                /// Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `root_as_signed_message_unchecked`.
                pub fn root_as_signed_message_with_opts<'b, 'o>(
                    opts: &'o flatbuffers::VerifierOptions,
                    buf: &'b [u8],
                ) -> Result<SignedMessage<'b>, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::root_with_opts::<SignedMessage<'b>>(opts, buf)
                }
                #[inline]
                /// Verifies, with the given verifier options, that a buffer of
                /// bytes contains a size prefixed `SignedMessage` and returns
                /// it. Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `root_as_signed_message_unchecked`.
                pub fn size_prefixed_root_as_signed_message_with_opts<'b, 'o>(
                    opts: &'o flatbuffers::VerifierOptions,
                    buf: &'b [u8],
                ) -> Result<SignedMessage<'b>, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::size_prefixed_root_with_opts::<SignedMessage<'b>>(opts, buf)
                }
                #[inline]
                /// Assumes, without verification, that a buffer of bytes contains a SignedMessage and returns it.
                /// # Safety
                /// Callers must trust the given bytes do indeed contain a valid `SignedMessage`.
                pub unsafe fn root_as_signed_message_unchecked(buf: &[u8]) -> SignedMessage {
                    flatbuffers::root_unchecked::<SignedMessage>(buf)
                }
                #[inline]
                /// Assumes, without verification, that a buffer of bytes contains a size prefixed SignedMessage and returns it.
                /// # Safety
                /// Callers must trust the given bytes do indeed contain a valid size prefixed `SignedMessage`.
                pub unsafe fn size_prefixed_root_as_signed_message_unchecked(
                    buf: &[u8],
                ) -> SignedMessage {
                    flatbuffers::size_prefixed_root_unchecked::<SignedMessage>(buf)
                }
                #[inline]
                pub fn finish_signed_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
                    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    root: flatbuffers::WIPOffset<SignedMessage<'a>>,
                ) {
                    fbb.finish(root, None);
                }

                #[inline]
                pub fn finish_size_prefixed_signed_message_buffer<
                    'a,
                    'b,
                    A: flatbuffers::Allocator + 'a,
                >(
                    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    root: flatbuffers::WIPOffset<SignedMessage<'a>>,
                ) {
                    fbb.finish_size_prefixed(root, None);
                }
            } // pub mod message
        } // pub mod fb
    } // pub mod subjugated
} // pub mod club
