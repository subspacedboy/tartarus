// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod club {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod subjugated {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod fb {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod message {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_END_CONDITION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_END_CONDITION: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_END_CONDITION: [EndCondition; 3] = [
  EndCondition::NONE,
  EndCondition::TimeEndCondition,
  EndCondition::WhenISaySo,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EndCondition(pub u8);
#[allow(non_upper_case_globals)]
impl EndCondition {
  pub const NONE: Self = Self(0);
  pub const TimeEndCondition: Self = Self(1);
  pub const WhenISaySo: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::TimeEndCondition,
    Self::WhenISaySo,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::TimeEndCondition => Some("TimeEndCondition"),
      Self::WhenISaySo => Some("WhenISaySo"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for EndCondition {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for EndCondition {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for EndCondition {
    type Output = EndCondition;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for EndCondition {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for EndCondition {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for EndCondition {}
pub struct EndConditionUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_UPDATE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_UPDATE_TYPE: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_UPDATE_TYPE: [UpdateType; 5] = [
  UpdateType::Undefined,
  UpdateType::Started,
  UpdateType::Locked,
  UpdateType::Unlocked,
  UpdateType::Error,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct UpdateType(pub i8);
#[allow(non_upper_case_globals)]
impl UpdateType {
  pub const Undefined: Self = Self(0);
  pub const Started: Self = Self(1);
  pub const Locked: Self = Self(2);
  pub const Unlocked: Self = Self(3);
  pub const Error: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Undefined,
    Self::Started,
    Self::Locked,
    Self::Unlocked,
    Self::Error,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Undefined => Some("Undefined"),
      Self::Started => Some("Started"),
      Self::Locked => Some("Locked"),
      Self::Unlocked => Some("Unlocked"),
      Self::Error => Some("Error"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for UpdateType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for UpdateType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for UpdateType {
    type Output = UpdateType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for UpdateType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for UpdateType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for UpdateType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE_PAYLOAD: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE_PAYLOAD: u8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE_PAYLOAD: [MessagePayload; 6] = [
  MessagePayload::NONE,
  MessagePayload::Contract,
  MessagePayload::LockUpdateEvent,
  MessagePayload::LockCommand,
  MessagePayload::UnlockCommand,
  MessagePayload::ReleaseCommand,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MessagePayload(pub u8);
#[allow(non_upper_case_globals)]
impl MessagePayload {
  pub const NONE: Self = Self(0);
  pub const Contract: Self = Self(1);
  pub const LockUpdateEvent: Self = Self(2);
  pub const LockCommand: Self = Self(3);
  pub const UnlockCommand: Self = Self(4);
  pub const ReleaseCommand: Self = Self(5);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Contract,
    Self::LockUpdateEvent,
    Self::LockCommand,
    Self::UnlockCommand,
    Self::ReleaseCommand,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Contract => Some("Contract"),
      Self::LockUpdateEvent => Some("LockUpdateEvent"),
      Self::LockCommand => Some("LockCommand"),
      Self::UnlockCommand => Some("UnlockCommand"),
      Self::ReleaseCommand => Some("ReleaseCommand"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MessagePayload {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MessagePayload {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MessagePayload {
    type Output = MessagePayload;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MessagePayload {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MessagePayload {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MessagePayload {}
pub struct MessagePayloadUnionTableOffset {}

pub enum TimeEndConditionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TimeEndCondition<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TimeEndCondition<'a> {
  type Inner = TimeEndCondition<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TimeEndCondition<'a> {
  pub const VT_SECONDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TimeEndCondition { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TimeEndConditionArgs
  ) -> flatbuffers::WIPOffset<TimeEndCondition<'bldr>> {
    let mut builder = TimeEndConditionBuilder::new(_fbb);
    builder.add_seconds(args.seconds);
    builder.finish()
  }


  #[inline]
  pub fn seconds(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(TimeEndCondition::VT_SECONDS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TimeEndCondition<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("seconds", Self::VT_SECONDS, false)?
     .finish();
    Ok(())
  }
}
pub struct TimeEndConditionArgs {
    pub seconds: u64,
}
impl<'a> Default for TimeEndConditionArgs {
  #[inline]
  fn default() -> Self {
    TimeEndConditionArgs {
      seconds: 0,
    }
  }
}

pub struct TimeEndConditionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TimeEndConditionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_seconds(&mut self, seconds: u64) {
    self.fbb_.push_slot::<u64>(TimeEndCondition::VT_SECONDS, seconds, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TimeEndConditionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TimeEndConditionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TimeEndCondition<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TimeEndCondition<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TimeEndCondition");
      ds.field("seconds", &self.seconds());
      ds.finish()
  }
}
pub enum WhenISaySoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WhenISaySo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WhenISaySo<'a> {
  type Inner = WhenISaySo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WhenISaySo<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WhenISaySo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args WhenISaySoArgs
  ) -> flatbuffers::WIPOffset<WhenISaySo<'bldr>> {
    let mut builder = WhenISaySoBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for WhenISaySo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct WhenISaySoArgs {
}
impl<'a> Default for WhenISaySoArgs {
  #[inline]
  fn default() -> Self {
    WhenISaySoArgs {
    }
  }
}

pub struct WhenISaySoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WhenISaySoBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WhenISaySoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WhenISaySoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WhenISaySo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WhenISaySo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WhenISaySo");
      ds.finish()
  }
}
pub enum WebHookOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WebHook<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WebHook<'a> {
  type Inner = WebHook<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WebHook<'a> {
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WebHook { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args WebHookArgs<'args>
  ) -> flatbuffers::WIPOffset<WebHook<'bldr>> {
    let mut builder = WebHookBuilder::new(_fbb);
    if let Some(x) = args.address { builder.add_address(x); }
    builder.finish()
  }


  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WebHook::VT_ADDRESS, None)}
  }
}

impl flatbuffers::Verifiable for WebHook<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("address", Self::VT_ADDRESS, false)?
     .finish();
    Ok(())
  }
}
pub struct WebHookArgs<'a> {
    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for WebHookArgs<'a> {
  #[inline]
  fn default() -> Self {
    WebHookArgs {
      address: None,
    }
  }
}

pub struct WebHookBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WebHookBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WebHook::VT_ADDRESS, address);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WebHookBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WebHookBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WebHook<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WebHook<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WebHook");
      ds.field("address", &self.address());
      ds.finish()
  }
}
pub enum TemporaryUnlockRulesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TemporaryUnlockRules<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TemporaryUnlockRules<'a> {
  type Inner = TemporaryUnlockRules<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TemporaryUnlockRules<'a> {
  pub const VT_MAX_UNLOCKS: flatbuffers::VOffsetT = 4;
  pub const VT_TIME_LIMIT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TemporaryUnlockRules { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TemporaryUnlockRulesArgs
  ) -> flatbuffers::WIPOffset<TemporaryUnlockRules<'bldr>> {
    let mut builder = TemporaryUnlockRulesBuilder::new(_fbb);
    builder.add_time_limit(args.time_limit);
    builder.add_max_unlocks(args.max_unlocks);
    builder.finish()
  }


  #[inline]
  pub fn max_unlocks(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TemporaryUnlockRules::VT_MAX_UNLOCKS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn time_limit(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TemporaryUnlockRules::VT_TIME_LIMIT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TemporaryUnlockRules<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("max_unlocks", Self::VT_MAX_UNLOCKS, false)?
     .visit_field::<u16>("time_limit", Self::VT_TIME_LIMIT, false)?
     .finish();
    Ok(())
  }
}
pub struct TemporaryUnlockRulesArgs {
    pub max_unlocks: u16,
    pub time_limit: u16,
}
impl<'a> Default for TemporaryUnlockRulesArgs {
  #[inline]
  fn default() -> Self {
    TemporaryUnlockRulesArgs {
      max_unlocks: 0,
      time_limit: 0,
    }
  }
}

pub struct TemporaryUnlockRulesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TemporaryUnlockRulesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_max_unlocks(&mut self, max_unlocks: u16) {
    self.fbb_.push_slot::<u16>(TemporaryUnlockRules::VT_MAX_UNLOCKS, max_unlocks, 0);
  }
  #[inline]
  pub fn add_time_limit(&mut self, time_limit: u16) {
    self.fbb_.push_slot::<u16>(TemporaryUnlockRules::VT_TIME_LIMIT, time_limit, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TemporaryUnlockRulesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TemporaryUnlockRulesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TemporaryUnlockRules<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TemporaryUnlockRules<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TemporaryUnlockRules");
      ds.field("max_unlocks", &self.max_unlocks());
      ds.field("time_limit", &self.time_limit());
      ds.finish()
  }
}
pub enum ContractOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Contract<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Contract<'a> {
  type Inner = Contract<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Contract<'a> {
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_NONCE: flatbuffers::VOffsetT = 6;
  pub const VT_CONFIRM_CODE: flatbuffers::VOffsetT = 8;
  pub const VT_NOTES: flatbuffers::VOffsetT = 10;
  pub const VT_IS_UNREMOVABLE: flatbuffers::VOffsetT = 12;
  pub const VT_END_CONDITION_TYPE: flatbuffers::VOffsetT = 14;
  pub const VT_END_CONDITION: flatbuffers::VOffsetT = 16;
  pub const VT_WEBHOOKS: flatbuffers::VOffsetT = 18;
  pub const VT_IS_TEMPORARY_UNLOCK_ALLOWED: flatbuffers::VOffsetT = 20;
  pub const VT_UNLOCK_RULES: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Contract { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContractArgs<'args>
  ) -> flatbuffers::WIPOffset<Contract<'bldr>> {
    let mut builder = ContractBuilder::new(_fbb);
    if let Some(x) = args.unlock_rules { builder.add_unlock_rules(x); }
    if let Some(x) = args.webhooks { builder.add_webhooks(x); }
    if let Some(x) = args.end_condition { builder.add_end_condition(x); }
    if let Some(x) = args.notes { builder.add_notes(x); }
    if let Some(x) = args.confirm_code { builder.add_confirm_code(x); }
    if let Some(x) = args.nonce { builder.add_nonce(x); }
    if let Some(x) = args.public_key { builder.add_public_key(x); }
    builder.add_is_temporary_unlock_allowed(args.is_temporary_unlock_allowed);
    builder.add_end_condition_type(args.end_condition_type);
    builder.add_is_unremovable(args.is_unremovable);
    builder.finish()
  }


  #[inline]
  pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Contract::VT_PUBLIC_KEY, None)}
  }
  #[inline]
  pub fn nonce(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Contract::VT_NONCE, None)}
  }
  #[inline]
  pub fn confirm_code(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Contract::VT_CONFIRM_CODE, None)}
  }
  #[inline]
  pub fn notes(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Contract::VT_NOTES, None)}
  }
  #[inline]
  pub fn is_unremovable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Contract::VT_IS_UNREMOVABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn end_condition_type(&self) -> EndCondition {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EndCondition>(Contract::VT_END_CONDITION_TYPE, Some(EndCondition::NONE)).unwrap()}
  }
  #[inline]
  pub fn end_condition(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Contract::VT_END_CONDITION, None)}
  }
  #[inline]
  pub fn webhooks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WebHook<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WebHook>>>>(Contract::VT_WEBHOOKS, None)}
  }
  #[inline]
  pub fn is_temporary_unlock_allowed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Contract::VT_IS_TEMPORARY_UNLOCK_ALLOWED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn unlock_rules(&self) -> Option<TemporaryUnlockRules<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TemporaryUnlockRules>>(Contract::VT_UNLOCK_RULES, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn end_condition_as_time_end_condition(&self) -> Option<TimeEndCondition<'a>> {
    if self.end_condition_type() == EndCondition::TimeEndCondition {
      self.end_condition().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TimeEndCondition::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn end_condition_as_when_isay_so(&self) -> Option<WhenISaySo<'a>> {
    if self.end_condition_type() == EndCondition::WhenISaySo {
      self.end_condition().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { WhenISaySo::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Contract<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("nonce", Self::VT_NONCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("confirm_code", Self::VT_CONFIRM_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("notes", Self::VT_NOTES, false)?
     .visit_field::<bool>("is_unremovable", Self::VT_IS_UNREMOVABLE, false)?
     .visit_union::<EndCondition, _>("end_condition_type", Self::VT_END_CONDITION_TYPE, "end_condition", Self::VT_END_CONDITION, false, |key, v, pos| {
        match key {
          EndCondition::TimeEndCondition => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TimeEndCondition>>("EndCondition::TimeEndCondition", pos),
          EndCondition::WhenISaySo => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WhenISaySo>>("EndCondition::WhenISaySo", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WebHook>>>>("webhooks", Self::VT_WEBHOOKS, false)?
     .visit_field::<bool>("is_temporary_unlock_allowed", Self::VT_IS_TEMPORARY_UNLOCK_ALLOWED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TemporaryUnlockRules>>("unlock_rules", Self::VT_UNLOCK_RULES, false)?
     .finish();
    Ok(())
  }
}
pub struct ContractArgs<'a> {
    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub nonce: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub confirm_code: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub notes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_unremovable: bool,
    pub end_condition_type: EndCondition,
    pub end_condition: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub webhooks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WebHook<'a>>>>>,
    pub is_temporary_unlock_allowed: bool,
    pub unlock_rules: Option<flatbuffers::WIPOffset<TemporaryUnlockRules<'a>>>,
}
impl<'a> Default for ContractArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContractArgs {
      public_key: None,
      nonce: None,
      confirm_code: None,
      notes: None,
      is_unremovable: false,
      end_condition_type: EndCondition::NONE,
      end_condition: None,
      webhooks: None,
      is_temporary_unlock_allowed: false,
      unlock_rules: None,
    }
  }
}

pub struct ContractBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContractBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_public_key(&mut self, public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contract::VT_PUBLIC_KEY, public_key);
  }
  #[inline]
  pub fn add_nonce(&mut self, nonce: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contract::VT_NONCE, nonce);
  }
  #[inline]
  pub fn add_confirm_code(&mut self, confirm_code: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contract::VT_CONFIRM_CODE, confirm_code);
  }
  #[inline]
  pub fn add_notes(&mut self, notes: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contract::VT_NOTES, notes);
  }
  #[inline]
  pub fn add_is_unremovable(&mut self, is_unremovable: bool) {
    self.fbb_.push_slot::<bool>(Contract::VT_IS_UNREMOVABLE, is_unremovable, false);
  }
  #[inline]
  pub fn add_end_condition_type(&mut self, end_condition_type: EndCondition) {
    self.fbb_.push_slot::<EndCondition>(Contract::VT_END_CONDITION_TYPE, end_condition_type, EndCondition::NONE);
  }
  #[inline]
  pub fn add_end_condition(&mut self, end_condition: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contract::VT_END_CONDITION, end_condition);
  }
  #[inline]
  pub fn add_webhooks(&mut self, webhooks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WebHook<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contract::VT_WEBHOOKS, webhooks);
  }
  #[inline]
  pub fn add_is_temporary_unlock_allowed(&mut self, is_temporary_unlock_allowed: bool) {
    self.fbb_.push_slot::<bool>(Contract::VT_IS_TEMPORARY_UNLOCK_ALLOWED, is_temporary_unlock_allowed, false);
  }
  #[inline]
  pub fn add_unlock_rules(&mut self, unlock_rules: flatbuffers::WIPOffset<TemporaryUnlockRules<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TemporaryUnlockRules>>(Contract::VT_UNLOCK_RULES, unlock_rules);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContractBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContractBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Contract<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Contract<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Contract");
      ds.field("public_key", &self.public_key());
      ds.field("nonce", &self.nonce());
      ds.field("confirm_code", &self.confirm_code());
      ds.field("notes", &self.notes());
      ds.field("is_unremovable", &self.is_unremovable());
      ds.field("end_condition_type", &self.end_condition_type());
      match self.end_condition_type() {
        EndCondition::TimeEndCondition => {
          if let Some(x) = self.end_condition_as_time_end_condition() {
            ds.field("end_condition", &x)
          } else {
            ds.field("end_condition", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EndCondition::WhenISaySo => {
          if let Some(x) = self.end_condition_as_when_isay_so() {
            ds.field("end_condition", &x)
          } else {
            ds.field("end_condition", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("end_condition", &x)
        },
      };
      ds.field("webhooks", &self.webhooks());
      ds.field("is_temporary_unlock_allowed", &self.is_temporary_unlock_allowed());
      ds.field("unlock_rules", &self.unlock_rules());
      ds.finish()
  }
}
pub enum SimpleContractOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SimpleContract<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SimpleContract<'a> {
  type Inner = SimpleContract<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SimpleContract<'a> {
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_NONCE: flatbuffers::VOffsetT = 6;
  pub const VT_CONFIRM_CODE: flatbuffers::VOffsetT = 8;
  pub const VT_IS_UNREMOVABLE: flatbuffers::VOffsetT = 10;
  pub const VT_END_CONDITION_TYPE: flatbuffers::VOffsetT = 12;
  pub const VT_END_CONDITION: flatbuffers::VOffsetT = 14;
  pub const VT_IS_TEMPORARY_UNLOCK_ALLOWED: flatbuffers::VOffsetT = 16;
  pub const VT_UNLOCK_RULES: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SimpleContract { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SimpleContractArgs<'args>
  ) -> flatbuffers::WIPOffset<SimpleContract<'bldr>> {
    let mut builder = SimpleContractBuilder::new(_fbb);
    if let Some(x) = args.unlock_rules { builder.add_unlock_rules(x); }
    if let Some(x) = args.end_condition { builder.add_end_condition(x); }
    if let Some(x) = args.confirm_code { builder.add_confirm_code(x); }
    if let Some(x) = args.nonce { builder.add_nonce(x); }
    if let Some(x) = args.public_key { builder.add_public_key(x); }
    builder.add_is_temporary_unlock_allowed(args.is_temporary_unlock_allowed);
    builder.add_end_condition_type(args.end_condition_type);
    builder.add_is_unremovable(args.is_unremovable);
    builder.finish()
  }


  #[inline]
  pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SimpleContract::VT_PUBLIC_KEY, None)}
  }
  #[inline]
  pub fn nonce(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SimpleContract::VT_NONCE, None)}
  }
  #[inline]
  pub fn confirm_code(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SimpleContract::VT_CONFIRM_CODE, None)}
  }
  #[inline]
  pub fn is_unremovable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SimpleContract::VT_IS_UNREMOVABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn end_condition_type(&self) -> EndCondition {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EndCondition>(SimpleContract::VT_END_CONDITION_TYPE, Some(EndCondition::NONE)).unwrap()}
  }
  #[inline]
  pub fn end_condition(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(SimpleContract::VT_END_CONDITION, None)}
  }
  #[inline]
  pub fn is_temporary_unlock_allowed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SimpleContract::VT_IS_TEMPORARY_UNLOCK_ALLOWED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn unlock_rules(&self) -> Option<TemporaryUnlockRules<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TemporaryUnlockRules>>(SimpleContract::VT_UNLOCK_RULES, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn end_condition_as_time_end_condition(&self) -> Option<TimeEndCondition<'a>> {
    if self.end_condition_type() == EndCondition::TimeEndCondition {
      self.end_condition().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TimeEndCondition::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn end_condition_as_when_isay_so(&self) -> Option<WhenISaySo<'a>> {
    if self.end_condition_type() == EndCondition::WhenISaySo {
      self.end_condition().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { WhenISaySo::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for SimpleContract<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("nonce", Self::VT_NONCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("confirm_code", Self::VT_CONFIRM_CODE, false)?
     .visit_field::<bool>("is_unremovable", Self::VT_IS_UNREMOVABLE, false)?
     .visit_union::<EndCondition, _>("end_condition_type", Self::VT_END_CONDITION_TYPE, "end_condition", Self::VT_END_CONDITION, false, |key, v, pos| {
        match key {
          EndCondition::TimeEndCondition => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TimeEndCondition>>("EndCondition::TimeEndCondition", pos),
          EndCondition::WhenISaySo => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WhenISaySo>>("EndCondition::WhenISaySo", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<bool>("is_temporary_unlock_allowed", Self::VT_IS_TEMPORARY_UNLOCK_ALLOWED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TemporaryUnlockRules>>("unlock_rules", Self::VT_UNLOCK_RULES, false)?
     .finish();
    Ok(())
  }
}
pub struct SimpleContractArgs<'a> {
    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub nonce: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub confirm_code: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub is_unremovable: bool,
    pub end_condition_type: EndCondition,
    pub end_condition: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub is_temporary_unlock_allowed: bool,
    pub unlock_rules: Option<flatbuffers::WIPOffset<TemporaryUnlockRules<'a>>>,
}
impl<'a> Default for SimpleContractArgs<'a> {
  #[inline]
  fn default() -> Self {
    SimpleContractArgs {
      public_key: None,
      nonce: None,
      confirm_code: None,
      is_unremovable: false,
      end_condition_type: EndCondition::NONE,
      end_condition: None,
      is_temporary_unlock_allowed: false,
      unlock_rules: None,
    }
  }
}

pub struct SimpleContractBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SimpleContractBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_public_key(&mut self, public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SimpleContract::VT_PUBLIC_KEY, public_key);
  }
  #[inline]
  pub fn add_nonce(&mut self, nonce: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SimpleContract::VT_NONCE, nonce);
  }
  #[inline]
  pub fn add_confirm_code(&mut self, confirm_code: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SimpleContract::VT_CONFIRM_CODE, confirm_code);
  }
  #[inline]
  pub fn add_is_unremovable(&mut self, is_unremovable: bool) {
    self.fbb_.push_slot::<bool>(SimpleContract::VT_IS_UNREMOVABLE, is_unremovable, false);
  }
  #[inline]
  pub fn add_end_condition_type(&mut self, end_condition_type: EndCondition) {
    self.fbb_.push_slot::<EndCondition>(SimpleContract::VT_END_CONDITION_TYPE, end_condition_type, EndCondition::NONE);
  }
  #[inline]
  pub fn add_end_condition(&mut self, end_condition: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SimpleContract::VT_END_CONDITION, end_condition);
  }
  #[inline]
  pub fn add_is_temporary_unlock_allowed(&mut self, is_temporary_unlock_allowed: bool) {
    self.fbb_.push_slot::<bool>(SimpleContract::VT_IS_TEMPORARY_UNLOCK_ALLOWED, is_temporary_unlock_allowed, false);
  }
  #[inline]
  pub fn add_unlock_rules(&mut self, unlock_rules: flatbuffers::WIPOffset<TemporaryUnlockRules<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TemporaryUnlockRules>>(SimpleContract::VT_UNLOCK_RULES, unlock_rules);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SimpleContractBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SimpleContractBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SimpleContract<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SimpleContract<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SimpleContract");
      ds.field("public_key", &self.public_key());
      ds.field("nonce", &self.nonce());
      ds.field("confirm_code", &self.confirm_code());
      ds.field("is_unremovable", &self.is_unremovable());
      ds.field("end_condition_type", &self.end_condition_type());
      match self.end_condition_type() {
        EndCondition::TimeEndCondition => {
          if let Some(x) = self.end_condition_as_time_end_condition() {
            ds.field("end_condition", &x)
          } else {
            ds.field("end_condition", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EndCondition::WhenISaySo => {
          if let Some(x) = self.end_condition_as_when_isay_so() {
            ds.field("end_condition", &x)
          } else {
            ds.field("end_condition", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("end_condition", &x)
        },
      };
      ds.field("is_temporary_unlock_allowed", &self.is_temporary_unlock_allowed());
      ds.field("unlock_rules", &self.unlock_rules());
      ds.finish()
  }
}
pub enum LockUpdateEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LockUpdateEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LockUpdateEvent<'a> {
  type Inner = LockUpdateEvent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LockUpdateEvent<'a> {
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_SESSION: flatbuffers::VOffsetT = 6;
  pub const VT_BODY: flatbuffers::VOffsetT = 8;
  pub const VT_THIS_UPDATE_TYPE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LockUpdateEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LockUpdateEventArgs<'args>
  ) -> flatbuffers::WIPOffset<LockUpdateEvent<'bldr>> {
    let mut builder = LockUpdateEventBuilder::new(_fbb);
    if let Some(x) = args.body { builder.add_body(x); }
    if let Some(x) = args.session { builder.add_session(x); }
    if let Some(x) = args.public_key { builder.add_public_key(x); }
    builder.add_this_update_type(args.this_update_type);
    builder.finish()
  }


  #[inline]
  pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(LockUpdateEvent::VT_PUBLIC_KEY, None)}
  }
  #[inline]
  pub fn session(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LockUpdateEvent::VT_SESSION, None)}
  }
  #[inline]
  pub fn body(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LockUpdateEvent::VT_BODY, None)}
  }
  #[inline]
  pub fn this_update_type(&self) -> UpdateType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<UpdateType>(LockUpdateEvent::VT_THIS_UPDATE_TYPE, Some(UpdateType::Undefined)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LockUpdateEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("session", Self::VT_SESSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("body", Self::VT_BODY, false)?
     .visit_field::<UpdateType>("this_update_type", Self::VT_THIS_UPDATE_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct LockUpdateEventArgs<'a> {
    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub session: Option<flatbuffers::WIPOffset<&'a str>>,
    pub body: Option<flatbuffers::WIPOffset<&'a str>>,
    pub this_update_type: UpdateType,
}
impl<'a> Default for LockUpdateEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    LockUpdateEventArgs {
      public_key: None,
      session: None,
      body: None,
      this_update_type: UpdateType::Undefined,
    }
  }
}

pub struct LockUpdateEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LockUpdateEventBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_public_key(&mut self, public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LockUpdateEvent::VT_PUBLIC_KEY, public_key);
  }
  #[inline]
  pub fn add_session(&mut self, session: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LockUpdateEvent::VT_SESSION, session);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LockUpdateEvent::VT_BODY, body);
  }
  #[inline]
  pub fn add_this_update_type(&mut self, this_update_type: UpdateType) {
    self.fbb_.push_slot::<UpdateType>(LockUpdateEvent::VT_THIS_UPDATE_TYPE, this_update_type, UpdateType::Undefined);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LockUpdateEventBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LockUpdateEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LockUpdateEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LockUpdateEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LockUpdateEvent");
      ds.field("public_key", &self.public_key());
      ds.field("session", &self.session());
      ds.field("body", &self.body());
      ds.field("this_update_type", &self.this_update_type());
      ds.finish()
  }
}
pub enum LockCommandOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LockCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LockCommand<'a> {
  type Inner = LockCommand<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LockCommand<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LockCommand { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args LockCommandArgs
  ) -> flatbuffers::WIPOffset<LockCommand<'bldr>> {
    let mut builder = LockCommandBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for LockCommand<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct LockCommandArgs {
}
impl<'a> Default for LockCommandArgs {
  #[inline]
  fn default() -> Self {
    LockCommandArgs {
    }
  }
}

pub struct LockCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LockCommandBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LockCommandBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LockCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LockCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LockCommand<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LockCommand");
      ds.finish()
  }
}
pub enum UnlockCommandOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnlockCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnlockCommand<'a> {
  type Inner = UnlockCommand<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UnlockCommand<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnlockCommand { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args UnlockCommandArgs
  ) -> flatbuffers::WIPOffset<UnlockCommand<'bldr>> {
    let mut builder = UnlockCommandBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for UnlockCommand<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct UnlockCommandArgs {
}
impl<'a> Default for UnlockCommandArgs {
  #[inline]
  fn default() -> Self {
    UnlockCommandArgs {
    }
  }
}

pub struct UnlockCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnlockCommandBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UnlockCommandBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UnlockCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnlockCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnlockCommand<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnlockCommand");
      ds.finish()
  }
}
pub enum ReleaseCommandOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReleaseCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReleaseCommand<'a> {
  type Inner = ReleaseCommand<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ReleaseCommand<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReleaseCommand { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args ReleaseCommandArgs
  ) -> flatbuffers::WIPOffset<ReleaseCommand<'bldr>> {
    let mut builder = ReleaseCommandBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for ReleaseCommand<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ReleaseCommandArgs {
}
impl<'a> Default for ReleaseCommandArgs {
  #[inline]
  fn default() -> Self {
    ReleaseCommandArgs {
    }
  }
}

pub struct ReleaseCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReleaseCommandBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ReleaseCommandBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ReleaseCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReleaseCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReleaseCommand<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReleaseCommand");
      ds.finish()
  }
}
pub enum SignedMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SignedMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SignedMessage<'a> {
  type Inner = SignedMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SignedMessage<'a> {
  pub const VT_SIGNATURE: flatbuffers::VOffsetT = 4;
  pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_PAYLOAD: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SignedMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SignedMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<SignedMessage<'bldr>> {
    let mut builder = SignedMessageBuilder::new(_fbb);
    if let Some(x) = args.payload { builder.add_payload(x); }
    if let Some(x) = args.signature { builder.add_signature(x); }
    builder.add_payload_type(args.payload_type);
    builder.finish()
  }


  #[inline]
  pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SignedMessage::VT_SIGNATURE, None)}
  }
  #[inline]
  pub fn payload_type(&self) -> MessagePayload {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MessagePayload>(SignedMessage::VT_PAYLOAD_TYPE, Some(MessagePayload::NONE)).unwrap()}
  }
  #[inline]
  pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(SignedMessage::VT_PAYLOAD, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_contract(&self) -> Option<Contract<'a>> {
    if self.payload_type() == MessagePayload::Contract {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Contract::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_lock_update_event(&self) -> Option<LockUpdateEvent<'a>> {
    if self.payload_type() == MessagePayload::LockUpdateEvent {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LockUpdateEvent::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_lock_command(&self) -> Option<LockCommand<'a>> {
    if self.payload_type() == MessagePayload::LockCommand {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LockCommand::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_unlock_command(&self) -> Option<UnlockCommand<'a>> {
    if self.payload_type() == MessagePayload::UnlockCommand {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { UnlockCommand::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_release_command(&self) -> Option<ReleaseCommand<'a>> {
    if self.payload_type() == MessagePayload::ReleaseCommand {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ReleaseCommand::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for SignedMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("signature", Self::VT_SIGNATURE, false)?
     .visit_union::<MessagePayload, _>("payload_type", Self::VT_PAYLOAD_TYPE, "payload", Self::VT_PAYLOAD, false, |key, v, pos| {
        match key {
          MessagePayload::Contract => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Contract>>("MessagePayload::Contract", pos),
          MessagePayload::LockUpdateEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LockUpdateEvent>>("MessagePayload::LockUpdateEvent", pos),
          MessagePayload::LockCommand => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LockCommand>>("MessagePayload::LockCommand", pos),
          MessagePayload::UnlockCommand => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnlockCommand>>("MessagePayload::UnlockCommand", pos),
          MessagePayload::ReleaseCommand => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReleaseCommand>>("MessagePayload::ReleaseCommand", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct SignedMessageArgs<'a> {
    pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub payload_type: MessagePayload,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SignedMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    SignedMessageArgs {
      signature: None,
      payload_type: MessagePayload::NONE,
      payload: None,
    }
  }
}

pub struct SignedMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SignedMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_signature(&mut self, signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SignedMessage::VT_SIGNATURE, signature);
  }
  #[inline]
  pub fn add_payload_type(&mut self, payload_type: MessagePayload) {
    self.fbb_.push_slot::<MessagePayload>(SignedMessage::VT_PAYLOAD_TYPE, payload_type, MessagePayload::NONE);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SignedMessage::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SignedMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SignedMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SignedMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SignedMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SignedMessage");
      ds.field("signature", &self.signature());
      ds.field("payload_type", &self.payload_type());
      match self.payload_type() {
        MessagePayload::Contract => {
          if let Some(x) = self.payload_as_contract() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessagePayload::LockUpdateEvent => {
          if let Some(x) = self.payload_as_lock_update_event() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessagePayload::LockCommand => {
          if let Some(x) = self.payload_as_lock_command() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessagePayload::UnlockCommand => {
          if let Some(x) = self.payload_as_unlock_command() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessagePayload::ReleaseCommand => {
          if let Some(x) = self.payload_as_release_command() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("payload", &x)
        },
      };
      ds.finish()
  }
}
pub enum ConfigurationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Configuration<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Configuration<'a> {
  type Inner = Configuration<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Configuration<'a> {
  pub const VT_COORDINATOR_ADDRESS: flatbuffers::VOffsetT = 4;
  pub const VT_SAFETY_KEY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Configuration { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ConfigurationArgs<'args>
  ) -> flatbuffers::WIPOffset<Configuration<'bldr>> {
    let mut builder = ConfigurationBuilder::new(_fbb);
    if let Some(x) = args.safety_key { builder.add_safety_key(x); }
    if let Some(x) = args.coordinator_address { builder.add_coordinator_address(x); }
    builder.finish()
  }


  #[inline]
  pub fn coordinator_address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Configuration::VT_COORDINATOR_ADDRESS, None)}
  }
  #[inline]
  pub fn safety_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Configuration::VT_SAFETY_KEY, None)}
  }
}

impl flatbuffers::Verifiable for Configuration<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("coordinator_address", Self::VT_COORDINATOR_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("safety_key", Self::VT_SAFETY_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct ConfigurationArgs<'a> {
    pub coordinator_address: Option<flatbuffers::WIPOffset<&'a str>>,
    pub safety_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ConfigurationArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConfigurationArgs {
      coordinator_address: None,
      safety_key: None,
    }
  }
}

pub struct ConfigurationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConfigurationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_coordinator_address(&mut self, coordinator_address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Configuration::VT_COORDINATOR_ADDRESS, coordinator_address);
  }
  #[inline]
  pub fn add_safety_key(&mut self, safety_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Configuration::VT_SAFETY_KEY, safety_key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ConfigurationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ConfigurationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Configuration<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Configuration<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Configuration");
      ds.field("coordinator_address", &self.coordinator_address());
      ds.field("safety_key", &self.safety_key());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `SignedMessage`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_signed_message_unchecked`.
pub fn root_as_signed_message(buf: &[u8]) -> Result<SignedMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<SignedMessage>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SignedMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_signed_message_unchecked`.
pub fn size_prefixed_root_as_signed_message(buf: &[u8]) -> Result<SignedMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<SignedMessage>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SignedMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_signed_message_unchecked`.
pub fn root_as_signed_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SignedMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<SignedMessage<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SignedMessage` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_signed_message_unchecked`.
pub fn size_prefixed_root_as_signed_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SignedMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<SignedMessage<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SignedMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SignedMessage`.
pub unsafe fn root_as_signed_message_unchecked(buf: &[u8]) -> SignedMessage {
  flatbuffers::root_unchecked::<SignedMessage>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SignedMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SignedMessage`.
pub unsafe fn size_prefixed_root_as_signed_message_unchecked(buf: &[u8]) -> SignedMessage {
  flatbuffers::size_prefixed_root_unchecked::<SignedMessage>(buf)
}
#[inline]
pub fn finish_signed_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<SignedMessage<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_signed_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<SignedMessage<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod message
}  // pub mod fb
}  // pub mod subjugated
}  // pub mod club

