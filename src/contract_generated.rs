// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod subjugated {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod club {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CAPABILITIES: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CAPABILITIES: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CAPABILITIES: [Capabilities; 2] = [
  Capabilities::Online,
  Capabilities::Time,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Capabilities(pub i8);
#[allow(non_upper_case_globals)]
impl Capabilities {
  pub const Online: Self = Self(1);
  pub const Time: Self = Self(2);

  pub const ENUM_MIN: i8 = 1;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Online,
    Self::Time,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Online => Some("Online"),
      Self::Time => Some("Time"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Capabilities {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Capabilities {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Capabilities {
    type Output = Capabilities;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Capabilities {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Capabilities {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Capabilities {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_END_CONDITION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_END_CONDITION: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_END_CONDITION: [EndCondition; 3] = [
  EndCondition::NONE,
  EndCondition::TimeEndCondition,
  EndCondition::WhenISaySo,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EndCondition(pub u8);
#[allow(non_upper_case_globals)]
impl EndCondition {
  pub const NONE: Self = Self(0);
  pub const TimeEndCondition: Self = Self(1);
  pub const WhenISaySo: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::TimeEndCondition,
    Self::WhenISaySo,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::TimeEndCondition => Some("TimeEndCondition"),
      Self::WhenISaySo => Some("WhenISaySo"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for EndCondition {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for EndCondition {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for EndCondition {
    type Output = EndCondition;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for EndCondition {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for EndCondition {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for EndCondition {}
pub struct EndConditionUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE_PAYLOAD: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE_PAYLOAD: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE_PAYLOAD: [MessagePayload; 3] = [
  MessagePayload::NONE,
  MessagePayload::Contract,
  MessagePayload::PartialContract,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MessagePayload(pub u8);
#[allow(non_upper_case_globals)]
impl MessagePayload {
  pub const NONE: Self = Self(0);
  pub const Contract: Self = Self(1);
  pub const PartialContract: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Contract,
    Self::PartialContract,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Contract => Some("Contract"),
      Self::PartialContract => Some("PartialContract"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MessagePayload {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MessagePayload {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MessagePayload {
    type Output = MessagePayload;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MessagePayload {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MessagePayload {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MessagePayload {}
pub struct MessagePayloadUnionTableOffset {}

pub enum TimeEndConditionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TimeEndCondition<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TimeEndCondition<'a> {
  type Inner = TimeEndCondition<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TimeEndCondition<'a> {
  pub const VT_SECONDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TimeEndCondition { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TimeEndConditionArgs
  ) -> flatbuffers::WIPOffset<TimeEndCondition<'bldr>> {
    let mut builder = TimeEndConditionBuilder::new(_fbb);
    builder.add_seconds(args.seconds);
    builder.finish()
  }


  #[inline]
  pub fn seconds(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(TimeEndCondition::VT_SECONDS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TimeEndCondition<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("seconds", Self::VT_SECONDS, false)?
     .finish();
    Ok(())
  }
}
pub struct TimeEndConditionArgs {
    pub seconds: u64,
}
impl<'a> Default for TimeEndConditionArgs {
  #[inline]
  fn default() -> Self {
    TimeEndConditionArgs {
      seconds: 0,
    }
  }
}

pub struct TimeEndConditionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TimeEndConditionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_seconds(&mut self, seconds: u64) {
    self.fbb_.push_slot::<u64>(TimeEndCondition::VT_SECONDS, seconds, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TimeEndConditionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TimeEndConditionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TimeEndCondition<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TimeEndCondition<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TimeEndCondition");
      ds.field("seconds", &self.seconds());
      ds.finish()
  }
}
pub enum WhenISaySoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WhenISaySo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WhenISaySo<'a> {
  type Inner = WhenISaySo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WhenISaySo<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WhenISaySo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args WhenISaySoArgs
  ) -> flatbuffers::WIPOffset<WhenISaySo<'bldr>> {
    let mut builder = WhenISaySoBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for WhenISaySo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct WhenISaySoArgs {
}
impl<'a> Default for WhenISaySoArgs {
  #[inline]
  fn default() -> Self {
    WhenISaySoArgs {
    }
  }
}

pub struct WhenISaySoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WhenISaySoBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WhenISaySoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WhenISaySoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WhenISaySo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WhenISaySo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WhenISaySo");
      ds.finish()
  }
}
pub enum WebHookOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WebHook<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WebHook<'a> {
  type Inner = WebHook<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WebHook<'a> {
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WebHook { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args WebHookArgs<'args>
  ) -> flatbuffers::WIPOffset<WebHook<'bldr>> {
    let mut builder = WebHookBuilder::new(_fbb);
    if let Some(x) = args.address { builder.add_address(x); }
    builder.finish()
  }


  #[inline]
  pub fn address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WebHook::VT_ADDRESS, None)}
  }
}

impl flatbuffers::Verifiable for WebHook<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("address", Self::VT_ADDRESS, false)?
     .finish();
    Ok(())
  }
}
pub struct WebHookArgs<'a> {
    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for WebHookArgs<'a> {
  #[inline]
  fn default() -> Self {
    WebHookArgs {
      address: None,
    }
  }
}

pub struct WebHookBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WebHookBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WebHook::VT_ADDRESS, address);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WebHookBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WebHookBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WebHook<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WebHook<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WebHook");
      ds.field("address", &self.address());
      ds.finish()
  }
}
pub enum TemporaryUnlockRulesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TemporaryUnlockRules<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TemporaryUnlockRules<'a> {
  type Inner = TemporaryUnlockRules<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TemporaryUnlockRules<'a> {
  pub const VT_MAX_UNLOCKS: flatbuffers::VOffsetT = 4;
  pub const VT_TIME_LIMIT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TemporaryUnlockRules { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TemporaryUnlockRulesArgs
  ) -> flatbuffers::WIPOffset<TemporaryUnlockRules<'bldr>> {
    let mut builder = TemporaryUnlockRulesBuilder::new(_fbb);
    builder.add_time_limit(args.time_limit);
    builder.add_max_unlocks(args.max_unlocks);
    builder.finish()
  }


  #[inline]
  pub fn max_unlocks(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TemporaryUnlockRules::VT_MAX_UNLOCKS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn time_limit(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TemporaryUnlockRules::VT_TIME_LIMIT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TemporaryUnlockRules<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("max_unlocks", Self::VT_MAX_UNLOCKS, false)?
     .visit_field::<u16>("time_limit", Self::VT_TIME_LIMIT, false)?
     .finish();
    Ok(())
  }
}
pub struct TemporaryUnlockRulesArgs {
    pub max_unlocks: u16,
    pub time_limit: u16,
}
impl<'a> Default for TemporaryUnlockRulesArgs {
  #[inline]
  fn default() -> Self {
    TemporaryUnlockRulesArgs {
      max_unlocks: 0,
      time_limit: 0,
    }
  }
}

pub struct TemporaryUnlockRulesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TemporaryUnlockRulesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_max_unlocks(&mut self, max_unlocks: u16) {
    self.fbb_.push_slot::<u16>(TemporaryUnlockRules::VT_MAX_UNLOCKS, max_unlocks, 0);
  }
  #[inline]
  pub fn add_time_limit(&mut self, time_limit: u16) {
    self.fbb_.push_slot::<u16>(TemporaryUnlockRules::VT_TIME_LIMIT, time_limit, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TemporaryUnlockRulesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TemporaryUnlockRulesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TemporaryUnlockRules<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TemporaryUnlockRules<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TemporaryUnlockRules");
      ds.field("max_unlocks", &self.max_unlocks());
      ds.field("time_limit", &self.time_limit());
      ds.finish()
  }
}
pub enum ContractOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Contract<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Contract<'a> {
  type Inner = Contract<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Contract<'a> {
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_CAPABILITIES: flatbuffers::VOffsetT = 6;
  pub const VT_IS_UNREMOVABLE: flatbuffers::VOffsetT = 8;
  pub const VT_IS_BLIND: flatbuffers::VOffsetT = 10;
  pub const VT_ENCRYPTED_CONTRACT: flatbuffers::VOffsetT = 12;
  pub const VT_END_CONDITION_TYPE: flatbuffers::VOffsetT = 14;
  pub const VT_END_CONDITION: flatbuffers::VOffsetT = 16;
  pub const VT_PARTICIPANTS: flatbuffers::VOffsetT = 18;
  pub const VT_IS_LOCK_ON_ACCEPT: flatbuffers::VOffsetT = 20;
  pub const VT_IS_TEMPORARY_UNLOCK_ALLOWED: flatbuffers::VOffsetT = 22;
  pub const VT_UNLOCK_RULES: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Contract { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContractArgs<'args>
  ) -> flatbuffers::WIPOffset<Contract<'bldr>> {
    let mut builder = ContractBuilder::new(_fbb);
    if let Some(x) = args.unlock_rules { builder.add_unlock_rules(x); }
    if let Some(x) = args.participants { builder.add_participants(x); }
    if let Some(x) = args.end_condition { builder.add_end_condition(x); }
    if let Some(x) = args.encrypted_contract { builder.add_encrypted_contract(x); }
    if let Some(x) = args.capabilities { builder.add_capabilities(x); }
    if let Some(x) = args.public_key { builder.add_public_key(x); }
    builder.add_is_temporary_unlock_allowed(args.is_temporary_unlock_allowed);
    builder.add_is_lock_on_accept(args.is_lock_on_accept);
    builder.add_end_condition_type(args.end_condition_type);
    builder.add_is_blind(args.is_blind);
    builder.add_is_unremovable(args.is_unremovable);
    builder.finish()
  }


  #[inline]
  pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Contract::VT_PUBLIC_KEY, None)}
  }
  #[inline]
  pub fn capabilities(&self) -> Option<flatbuffers::Vector<'a, Capabilities>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Capabilities>>>(Contract::VT_CAPABILITIES, None)}
  }
  #[inline]
  pub fn is_unremovable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Contract::VT_IS_UNREMOVABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_blind(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Contract::VT_IS_BLIND, Some(false)).unwrap()}
  }
  #[inline]
  pub fn encrypted_contract(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Contract::VT_ENCRYPTED_CONTRACT, None)}
  }
  #[inline]
  pub fn end_condition_type(&self) -> EndCondition {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EndCondition>(Contract::VT_END_CONDITION_TYPE, Some(EndCondition::NONE)).unwrap()}
  }
  #[inline]
  pub fn end_condition(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Contract::VT_END_CONDITION, None)}
  }
  #[inline]
  pub fn participants(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WebHook<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WebHook>>>>(Contract::VT_PARTICIPANTS, None)}
  }
  #[inline]
  pub fn is_lock_on_accept(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Contract::VT_IS_LOCK_ON_ACCEPT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_temporary_unlock_allowed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Contract::VT_IS_TEMPORARY_UNLOCK_ALLOWED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn unlock_rules(&self) -> Option<TemporaryUnlockRules<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TemporaryUnlockRules>>(Contract::VT_UNLOCK_RULES, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn end_condition_as_time_end_condition(&self) -> Option<TimeEndCondition<'a>> {
    if self.end_condition_type() == EndCondition::TimeEndCondition {
      self.end_condition().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TimeEndCondition::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn end_condition_as_when_isay_so(&self) -> Option<WhenISaySo<'a>> {
    if self.end_condition_type() == EndCondition::WhenISaySo {
      self.end_condition().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { WhenISaySo::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Contract<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Capabilities>>>("capabilities", Self::VT_CAPABILITIES, false)?
     .visit_field::<bool>("is_unremovable", Self::VT_IS_UNREMOVABLE, false)?
     .visit_field::<bool>("is_blind", Self::VT_IS_BLIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("encrypted_contract", Self::VT_ENCRYPTED_CONTRACT, false)?
     .visit_union::<EndCondition, _>("end_condition_type", Self::VT_END_CONDITION_TYPE, "end_condition", Self::VT_END_CONDITION, false, |key, v, pos| {
        match key {
          EndCondition::TimeEndCondition => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TimeEndCondition>>("EndCondition::TimeEndCondition", pos),
          EndCondition::WhenISaySo => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WhenISaySo>>("EndCondition::WhenISaySo", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WebHook>>>>("participants", Self::VT_PARTICIPANTS, false)?
     .visit_field::<bool>("is_lock_on_accept", Self::VT_IS_LOCK_ON_ACCEPT, false)?
     .visit_field::<bool>("is_temporary_unlock_allowed", Self::VT_IS_TEMPORARY_UNLOCK_ALLOWED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TemporaryUnlockRules>>("unlock_rules", Self::VT_UNLOCK_RULES, false)?
     .finish();
    Ok(())
  }
}
pub struct ContractArgs<'a> {
    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub capabilities: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Capabilities>>>,
    pub is_unremovable: bool,
    pub is_blind: bool,
    pub encrypted_contract: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub end_condition_type: EndCondition,
    pub end_condition: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub participants: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WebHook<'a>>>>>,
    pub is_lock_on_accept: bool,
    pub is_temporary_unlock_allowed: bool,
    pub unlock_rules: Option<flatbuffers::WIPOffset<TemporaryUnlockRules<'a>>>,
}
impl<'a> Default for ContractArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContractArgs {
      public_key: None,
      capabilities: None,
      is_unremovable: false,
      is_blind: false,
      encrypted_contract: None,
      end_condition_type: EndCondition::NONE,
      end_condition: None,
      participants: None,
      is_lock_on_accept: false,
      is_temporary_unlock_allowed: false,
      unlock_rules: None,
    }
  }
}

pub struct ContractBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContractBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_public_key(&mut self, public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contract::VT_PUBLIC_KEY, public_key);
  }
  #[inline]
  pub fn add_capabilities(&mut self, capabilities: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Capabilities>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contract::VT_CAPABILITIES, capabilities);
  }
  #[inline]
  pub fn add_is_unremovable(&mut self, is_unremovable: bool) {
    self.fbb_.push_slot::<bool>(Contract::VT_IS_UNREMOVABLE, is_unremovable, false);
  }
  #[inline]
  pub fn add_is_blind(&mut self, is_blind: bool) {
    self.fbb_.push_slot::<bool>(Contract::VT_IS_BLIND, is_blind, false);
  }
  #[inline]
  pub fn add_encrypted_contract(&mut self, encrypted_contract: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contract::VT_ENCRYPTED_CONTRACT, encrypted_contract);
  }
  #[inline]
  pub fn add_end_condition_type(&mut self, end_condition_type: EndCondition) {
    self.fbb_.push_slot::<EndCondition>(Contract::VT_END_CONDITION_TYPE, end_condition_type, EndCondition::NONE);
  }
  #[inline]
  pub fn add_end_condition(&mut self, end_condition: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contract::VT_END_CONDITION, end_condition);
  }
  #[inline]
  pub fn add_participants(&mut self, participants: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WebHook<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contract::VT_PARTICIPANTS, participants);
  }
  #[inline]
  pub fn add_is_lock_on_accept(&mut self, is_lock_on_accept: bool) {
    self.fbb_.push_slot::<bool>(Contract::VT_IS_LOCK_ON_ACCEPT, is_lock_on_accept, false);
  }
  #[inline]
  pub fn add_is_temporary_unlock_allowed(&mut self, is_temporary_unlock_allowed: bool) {
    self.fbb_.push_slot::<bool>(Contract::VT_IS_TEMPORARY_UNLOCK_ALLOWED, is_temporary_unlock_allowed, false);
  }
  #[inline]
  pub fn add_unlock_rules(&mut self, unlock_rules: flatbuffers::WIPOffset<TemporaryUnlockRules<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TemporaryUnlockRules>>(Contract::VT_UNLOCK_RULES, unlock_rules);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContractBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContractBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Contract<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Contract<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Contract");
      ds.field("public_key", &self.public_key());
      ds.field("capabilities", &self.capabilities());
      ds.field("is_unremovable", &self.is_unremovable());
      ds.field("is_blind", &self.is_blind());
      ds.field("encrypted_contract", &self.encrypted_contract());
      ds.field("end_condition_type", &self.end_condition_type());
      match self.end_condition_type() {
        EndCondition::TimeEndCondition => {
          if let Some(x) = self.end_condition_as_time_end_condition() {
            ds.field("end_condition", &x)
          } else {
            ds.field("end_condition", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EndCondition::WhenISaySo => {
          if let Some(x) = self.end_condition_as_when_isay_so() {
            ds.field("end_condition", &x)
          } else {
            ds.field("end_condition", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("end_condition", &x)
        },
      };
      ds.field("participants", &self.participants());
      ds.field("is_lock_on_accept", &self.is_lock_on_accept());
      ds.field("is_temporary_unlock_allowed", &self.is_temporary_unlock_allowed());
      ds.field("unlock_rules", &self.unlock_rules());
      ds.finish()
  }
}
pub enum PartialContractOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PartialContract<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PartialContract<'a> {
  type Inner = PartialContract<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PartialContract<'a> {
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_COMPLETE_CONTRACT_ADDRESS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PartialContract { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PartialContractArgs<'args>
  ) -> flatbuffers::WIPOffset<PartialContract<'bldr>> {
    let mut builder = PartialContractBuilder::new(_fbb);
    if let Some(x) = args.complete_contract_address { builder.add_complete_contract_address(x); }
    if let Some(x) = args.public_key { builder.add_public_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PartialContract::VT_PUBLIC_KEY, None)}
  }
  #[inline]
  pub fn complete_contract_address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PartialContract::VT_COMPLETE_CONTRACT_ADDRESS, None)}
  }
}

impl flatbuffers::Verifiable for PartialContract<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("complete_contract_address", Self::VT_COMPLETE_CONTRACT_ADDRESS, false)?
     .finish();
    Ok(())
  }
}
pub struct PartialContractArgs<'a> {
    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub complete_contract_address: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PartialContractArgs<'a> {
  #[inline]
  fn default() -> Self {
    PartialContractArgs {
      public_key: None,
      complete_contract_address: None,
    }
  }
}

pub struct PartialContractBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PartialContractBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_public_key(&mut self, public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PartialContract::VT_PUBLIC_KEY, public_key);
  }
  #[inline]
  pub fn add_complete_contract_address(&mut self, complete_contract_address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PartialContract::VT_COMPLETE_CONTRACT_ADDRESS, complete_contract_address);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PartialContractBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PartialContractBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PartialContract<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PartialContract<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PartialContract");
      ds.field("public_key", &self.public_key());
      ds.field("complete_contract_address", &self.complete_contract_address());
      ds.finish()
  }
}
pub enum SignedMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SignedMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SignedMessage<'a> {
  type Inner = SignedMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SignedMessage<'a> {
  pub const VT_SIGNATURE: flatbuffers::VOffsetT = 4;
  pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_PAYLOAD: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SignedMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SignedMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<SignedMessage<'bldr>> {
    let mut builder = SignedMessageBuilder::new(_fbb);
    if let Some(x) = args.payload { builder.add_payload(x); }
    if let Some(x) = args.signature { builder.add_signature(x); }
    builder.add_payload_type(args.payload_type);
    builder.finish()
  }


  #[inline]
  pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SignedMessage::VT_SIGNATURE, None)}
  }
  #[inline]
  pub fn payload_type(&self) -> MessagePayload {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MessagePayload>(SignedMessage::VT_PAYLOAD_TYPE, Some(MessagePayload::NONE)).unwrap()}
  }
  #[inline]
  pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(SignedMessage::VT_PAYLOAD, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_contract(&self) -> Option<Contract<'a>> {
    if self.payload_type() == MessagePayload::Contract {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Contract::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_partial_contract(&self) -> Option<PartialContract<'a>> {
    if self.payload_type() == MessagePayload::PartialContract {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PartialContract::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for SignedMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("signature", Self::VT_SIGNATURE, false)?
     .visit_union::<MessagePayload, _>("payload_type", Self::VT_PAYLOAD_TYPE, "payload", Self::VT_PAYLOAD, false, |key, v, pos| {
        match key {
          MessagePayload::Contract => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Contract>>("MessagePayload::Contract", pos),
          MessagePayload::PartialContract => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PartialContract>>("MessagePayload::PartialContract", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct SignedMessageArgs<'a> {
    pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub payload_type: MessagePayload,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SignedMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    SignedMessageArgs {
      signature: None,
      payload_type: MessagePayload::NONE,
      payload: None,
    }
  }
}

pub struct SignedMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SignedMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_signature(&mut self, signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SignedMessage::VT_SIGNATURE, signature);
  }
  #[inline]
  pub fn add_payload_type(&mut self, payload_type: MessagePayload) {
    self.fbb_.push_slot::<MessagePayload>(SignedMessage::VT_PAYLOAD_TYPE, payload_type, MessagePayload::NONE);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SignedMessage::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SignedMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SignedMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SignedMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SignedMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SignedMessage");
      ds.field("signature", &self.signature());
      ds.field("payload_type", &self.payload_type());
      match self.payload_type() {
        MessagePayload::Contract => {
          if let Some(x) = self.payload_as_contract() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessagePayload::PartialContract => {
          if let Some(x) = self.payload_as_partial_contract() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("payload", &x)
        },
      };
      ds.finish()
  }
}
pub enum ConfigurationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Configuration<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Configuration<'a> {
  type Inner = Configuration<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Configuration<'a> {
  pub const VT_COORDINATOR_ADDRESS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Configuration { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ConfigurationArgs<'args>
  ) -> flatbuffers::WIPOffset<Configuration<'bldr>> {
    let mut builder = ConfigurationBuilder::new(_fbb);
    if let Some(x) = args.coordinator_address { builder.add_coordinator_address(x); }
    builder.finish()
  }


  #[inline]
  pub fn coordinator_address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Configuration::VT_COORDINATOR_ADDRESS, None)}
  }
}

impl flatbuffers::Verifiable for Configuration<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("coordinator_address", Self::VT_COORDINATOR_ADDRESS, false)?
     .finish();
    Ok(())
  }
}
pub struct ConfigurationArgs<'a> {
    pub coordinator_address: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ConfigurationArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConfigurationArgs {
      coordinator_address: None,
    }
  }
}

pub struct ConfigurationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ConfigurationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_coordinator_address(&mut self, coordinator_address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Configuration::VT_COORDINATOR_ADDRESS, coordinator_address);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ConfigurationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ConfigurationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Configuration<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Configuration<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Configuration");
      ds.field("coordinator_address", &self.coordinator_address());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `SignedMessage`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_signed_message_unchecked`.
pub fn root_as_signed_message(buf: &[u8]) -> Result<SignedMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<SignedMessage>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SignedMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_signed_message_unchecked`.
pub fn size_prefixed_root_as_signed_message(buf: &[u8]) -> Result<SignedMessage, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<SignedMessage>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SignedMessage` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_signed_message_unchecked`.
pub fn root_as_signed_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SignedMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<SignedMessage<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SignedMessage` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_signed_message_unchecked`.
pub fn size_prefixed_root_as_signed_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SignedMessage<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<SignedMessage<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SignedMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SignedMessage`.
pub unsafe fn root_as_signed_message_unchecked(buf: &[u8]) -> SignedMessage {
  flatbuffers::root_unchecked::<SignedMessage>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SignedMessage and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SignedMessage`.
pub unsafe fn size_prefixed_root_as_signed_message_unchecked(buf: &[u8]) -> SignedMessage {
  flatbuffers::size_prefixed_root_unchecked::<SignedMessage>(buf)
}
#[inline]
pub fn finish_signed_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<SignedMessage<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_signed_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<SignedMessage<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod club
}  // pub mod subjugated

