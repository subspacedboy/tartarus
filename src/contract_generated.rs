// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod club {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod subjugated {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};
        #[allow(unused_imports, dead_code)]
        pub mod fb {

            use core::cmp::Ordering;
            use core::mem;

            extern crate flatbuffers;
            use self::flatbuffers::{EndianScalar, Follow};
            #[allow(unused_imports, dead_code)]
            pub mod message {

                use core::cmp::Ordering;
                use core::mem;

                extern crate flatbuffers;
                use self::flatbuffers::{EndianScalar, Follow};

                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MIN_END_CONDITION: u8 = 0;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MAX_END_CONDITION: u8 = 2;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                #[allow(non_camel_case_types)]
                pub const ENUM_VALUES_END_CONDITION: [EndCondition; 3] = [
                    EndCondition::NONE,
                    EndCondition::TimeEndCondition,
                    EndCondition::WhenISaySo,
                ];

                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
                #[repr(transparent)]
                pub struct EndCondition(pub u8);
                #[allow(non_upper_case_globals)]
                impl EndCondition {
                    pub const NONE: Self = Self(0);
                    pub const TimeEndCondition: Self = Self(1);
                    pub const WhenISaySo: Self = Self(2);

                    pub const ENUM_MIN: u8 = 0;
                    pub const ENUM_MAX: u8 = 2;
                    pub const ENUM_VALUES: &'static [Self] =
                        &[Self::NONE, Self::TimeEndCondition, Self::WhenISaySo];
                    /// Returns the variant's name or "" if unknown.
                    pub fn variant_name(self) -> Option<&'static str> {
                        match self {
                            Self::NONE => Some("NONE"),
                            Self::TimeEndCondition => Some("TimeEndCondition"),
                            Self::WhenISaySo => Some("WhenISaySo"),
                            _ => None,
                        }
                    }
                }
                impl core::fmt::Debug for EndCondition {
                    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                        if let Some(name) = self.variant_name() {
                            f.write_str(name)
                        } else {
                            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                        }
                    }
                }
                impl<'a> flatbuffers::Follow<'a> for EndCondition {
                    type Inner = Self;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                        Self(b)
                    }
                }

                impl flatbuffers::Push for EndCondition {
                    type Output = EndCondition;
                    #[inline]
                    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                        flatbuffers::emplace_scalar::<u8>(dst, self.0);
                    }
                }

                impl flatbuffers::EndianScalar for EndCondition {
                    type Scalar = u8;
                    #[inline]
                    fn to_little_endian(self) -> u8 {
                        self.0.to_le()
                    }
                    #[inline]
                    #[allow(clippy::wrong_self_convention)]
                    fn from_little_endian(v: u8) -> Self {
                        let b = u8::from_le(v);
                        Self(b)
                    }
                }

                impl<'a> flatbuffers::Verifiable for EndCondition {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        u8::run_verifier(v, pos)
                    }
                }

                impl flatbuffers::SimpleToVerifyInSlice for EndCondition {}
                pub struct EndConditionUnionTableOffset {}

                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MIN_MESSAGE_PAYLOAD: u8 = 0;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                pub const ENUM_MAX_MESSAGE_PAYLOAD: u8 = 9;
                #[deprecated(
                    since = "2.0.0",
                    note = "Use associated constants instead. This will no longer be generated in 2021."
                )]
                #[allow(non_camel_case_types)]
                pub const ENUM_VALUES_MESSAGE_PAYLOAD: [MessagePayload; 10] = [
                    MessagePayload::NONE,
                    MessagePayload::Contract,
                    MessagePayload::LockCommand,
                    MessagePayload::UnlockCommand,
                    MessagePayload::ReleaseCommand,
                    MessagePayload::StartedUpdate,
                    MessagePayload::PeriodicUpdate,
                    MessagePayload::Acknowledgement,
                    MessagePayload::Error,
                    MessagePayload::AbortCommand,
                ];

                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
                #[repr(transparent)]
                pub struct MessagePayload(pub u8);
                #[allow(non_upper_case_globals)]
                impl MessagePayload {
                    pub const NONE: Self = Self(0);
                    pub const Contract: Self = Self(1);
                    pub const LockCommand: Self = Self(2);
                    pub const UnlockCommand: Self = Self(3);
                    pub const ReleaseCommand: Self = Self(4);
                    pub const StartedUpdate: Self = Self(5);
                    pub const PeriodicUpdate: Self = Self(6);
                    pub const Acknowledgement: Self = Self(7);
                    pub const Error: Self = Self(8);
                    pub const AbortCommand: Self = Self(9);

                    pub const ENUM_MIN: u8 = 0;
                    pub const ENUM_MAX: u8 = 9;
                    pub const ENUM_VALUES: &'static [Self] = &[
                        Self::NONE,
                        Self::Contract,
                        Self::LockCommand,
                        Self::UnlockCommand,
                        Self::ReleaseCommand,
                        Self::StartedUpdate,
                        Self::PeriodicUpdate,
                        Self::Acknowledgement,
                        Self::Error,
                        Self::AbortCommand,
                    ];
                    /// Returns the variant's name or "" if unknown.
                    pub fn variant_name(self) -> Option<&'static str> {
                        match self {
                            Self::NONE => Some("NONE"),
                            Self::Contract => Some("Contract"),
                            Self::LockCommand => Some("LockCommand"),
                            Self::UnlockCommand => Some("UnlockCommand"),
                            Self::ReleaseCommand => Some("ReleaseCommand"),
                            Self::StartedUpdate => Some("StartedUpdate"),
                            Self::PeriodicUpdate => Some("PeriodicUpdate"),
                            Self::Acknowledgement => Some("Acknowledgement"),
                            Self::Error => Some("Error"),
                            Self::AbortCommand => Some("AbortCommand"),
                            _ => None,
                        }
                    }
                }
                impl core::fmt::Debug for MessagePayload {
                    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                        if let Some(name) = self.variant_name() {
                            f.write_str(name)
                        } else {
                            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                        }
                    }
                }
                impl<'a> flatbuffers::Follow<'a> for MessagePayload {
                    type Inner = Self;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                        Self(b)
                    }
                }

                impl flatbuffers::Push for MessagePayload {
                    type Output = MessagePayload;
                    #[inline]
                    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                        flatbuffers::emplace_scalar::<u8>(dst, self.0);
                    }
                }

                impl flatbuffers::EndianScalar for MessagePayload {
                    type Scalar = u8;
                    #[inline]
                    fn to_little_endian(self) -> u8 {
                        self.0.to_le()
                    }
                    #[inline]
                    #[allow(clippy::wrong_self_convention)]
                    fn from_little_endian(v: u8) -> Self {
                        let b = u8::from_le(v);
                        Self(b)
                    }
                }

                impl<'a> flatbuffers::Verifiable for MessagePayload {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        u8::run_verifier(v, pos)
                    }
                }

                impl flatbuffers::SimpleToVerifyInSlice for MessagePayload {}
                pub struct MessagePayloadUnionTableOffset {}

                pub enum TimeEndConditionOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct TimeEndCondition<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for TimeEndCondition<'a> {
                    type Inner = TimeEndCondition<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> TimeEndCondition<'a> {
                    pub const VT_SECONDS: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        TimeEndCondition { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args TimeEndConditionArgs,
                    ) -> flatbuffers::WIPOffset<TimeEndCondition<'bldr>> {
                        let mut builder = TimeEndConditionBuilder::new(_fbb);
                        builder.add_seconds(args.seconds);
                        builder.finish()
                    }

                    #[inline]
                    pub fn seconds(&self) -> u64 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u64>(TimeEndCondition::VT_SECONDS, Some(0))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for TimeEndCondition<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<u64>("seconds", Self::VT_SECONDS, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct TimeEndConditionArgs {
                    pub seconds: u64,
                }
                impl<'a> Default for TimeEndConditionArgs {
                    #[inline]
                    fn default() -> Self {
                        TimeEndConditionArgs { seconds: 0 }
                    }
                }

                pub struct TimeEndConditionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TimeEndConditionBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_seconds(&mut self, seconds: u64) {
                        self.fbb_
                            .push_slot::<u64>(TimeEndCondition::VT_SECONDS, seconds, 0);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> TimeEndConditionBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        TimeEndConditionBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<TimeEndCondition<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for TimeEndCondition<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("TimeEndCondition");
                        ds.field("seconds", &self.seconds());
                        ds.finish()
                    }
                }
                pub enum WhenISaySoOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct WhenISaySo<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for WhenISaySo<'a> {
                    type Inner = WhenISaySo<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> WhenISaySo<'a> {
                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        WhenISaySo { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        _args: &'args WhenISaySoArgs,
                    ) -> flatbuffers::WIPOffset<WhenISaySo<'bldr>> {
                        let mut builder = WhenISaySoBuilder::new(_fbb);
                        builder.finish()
                    }
                }

                impl flatbuffers::Verifiable for WhenISaySo<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?.finish();
                        Ok(())
                    }
                }
                pub struct WhenISaySoArgs {}
                impl<'a> Default for WhenISaySoArgs {
                    #[inline]
                    fn default() -> Self {
                        WhenISaySoArgs {}
                    }
                }

                pub struct WhenISaySoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WhenISaySoBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> WhenISaySoBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        WhenISaySoBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<WhenISaySo<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for WhenISaySo<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("WhenISaySo");
                        ds.finish()
                    }
                }
                pub enum WebHookOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct WebHook<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for WebHook<'a> {
                    type Inner = WebHook<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> WebHook<'a> {
                    pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        WebHook { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args WebHookArgs<'args>,
                    ) -> flatbuffers::WIPOffset<WebHook<'bldr>> {
                        let mut builder = WebHookBuilder::new(_fbb);
                        if let Some(x) = args.address {
                            builder.add_address(x);
                        }
                        builder.finish()
                    }

                    #[inline]
                    pub fn address(&self) -> Option<&'a str> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                                WebHook::VT_ADDRESS,
                                None,
                            )
                        }
                    }
                }

                impl flatbuffers::Verifiable for WebHook<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                                "address",
                                Self::VT_ADDRESS,
                                false,
                            )?
                            .finish();
                        Ok(())
                    }
                }
                pub struct WebHookArgs<'a> {
                    pub address: Option<flatbuffers::WIPOffset<&'a str>>,
                }
                impl<'a> Default for WebHookArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        WebHookArgs { address: None }
                    }
                }

                pub struct WebHookBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WebHookBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            WebHook::VT_ADDRESS,
                            address,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> WebHookBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        WebHookBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<WebHook<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for WebHook<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("WebHook");
                        ds.field("address", &self.address());
                        ds.finish()
                    }
                }
                pub enum TemporaryUnlockRulesOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct TemporaryUnlockRules<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for TemporaryUnlockRules<'a> {
                    type Inner = TemporaryUnlockRules<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> TemporaryUnlockRules<'a> {
                    pub const VT_MAX_UNLOCKS: flatbuffers::VOffsetT = 4;
                    pub const VT_TIME_LIMIT: flatbuffers::VOffsetT = 6;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        TemporaryUnlockRules { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args TemporaryUnlockRulesArgs,
                    ) -> flatbuffers::WIPOffset<TemporaryUnlockRules<'bldr>> {
                        let mut builder = TemporaryUnlockRulesBuilder::new(_fbb);
                        builder.add_time_limit(args.time_limit);
                        builder.add_max_unlocks(args.max_unlocks);
                        builder.finish()
                    }

                    #[inline]
                    pub fn max_unlocks(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(TemporaryUnlockRules::VT_MAX_UNLOCKS, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn time_limit(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(TemporaryUnlockRules::VT_TIME_LIMIT, Some(0))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for TemporaryUnlockRules<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<u16>("max_unlocks", Self::VT_MAX_UNLOCKS, false)?
                            .visit_field::<u16>("time_limit", Self::VT_TIME_LIMIT, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct TemporaryUnlockRulesArgs {
                    pub max_unlocks: u16,
                    pub time_limit: u16,
                }
                impl<'a> Default for TemporaryUnlockRulesArgs {
                    #[inline]
                    fn default() -> Self {
                        TemporaryUnlockRulesArgs {
                            max_unlocks: 0,
                            time_limit: 0,
                        }
                    }
                }

                pub struct TemporaryUnlockRulesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TemporaryUnlockRulesBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_max_unlocks(&mut self, max_unlocks: u16) {
                        self.fbb_.push_slot::<u16>(
                            TemporaryUnlockRules::VT_MAX_UNLOCKS,
                            max_unlocks,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_time_limit(&mut self, time_limit: u16) {
                        self.fbb_.push_slot::<u16>(
                            TemporaryUnlockRules::VT_TIME_LIMIT,
                            time_limit,
                            0,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> TemporaryUnlockRulesBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        TemporaryUnlockRulesBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<TemporaryUnlockRules<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for TemporaryUnlockRules<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("TemporaryUnlockRules");
                        ds.field("max_unlocks", &self.max_unlocks());
                        ds.field("time_limit", &self.time_limit());
                        ds.finish()
                    }
                }
                pub enum ContractOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Contract<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Contract<'a> {
                    type Inner = Contract<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> Contract<'a> {
                    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 4;
                    pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 6;
                    pub const VT_NONCE: flatbuffers::VOffsetT = 8;
                    pub const VT_CONFIRM_CODE: flatbuffers::VOffsetT = 10;
                    pub const VT_END_CONDITION_TYPE: flatbuffers::VOffsetT = 12;
                    pub const VT_END_CONDITION: flatbuffers::VOffsetT = 14;
                    pub const VT_WEBHOOKS: flatbuffers::VOffsetT = 16;
                    pub const VT_IS_TEMPORARY_UNLOCK_ALLOWED: flatbuffers::VOffsetT = 18;
                    pub const VT_UNLOCK_RULES: flatbuffers::VOffsetT = 20;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Contract { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args ContractArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Contract<'bldr>> {
                        let mut builder = ContractBuilder::new(_fbb);
                        if let Some(x) = args.unlock_rules {
                            builder.add_unlock_rules(x);
                        }
                        if let Some(x) = args.webhooks {
                            builder.add_webhooks(x);
                        }
                        if let Some(x) = args.end_condition {
                            builder.add_end_condition(x);
                        }
                        if let Some(x) = args.confirm_code {
                            builder.add_confirm_code(x);
                        }
                        if let Some(x) = args.nonce {
                            builder.add_nonce(x);
                        }
                        if let Some(x) = args.public_key {
                            builder.add_public_key(x);
                        }
                        builder.add_serial_number(args.serial_number);
                        builder.add_is_temporary_unlock_allowed(args.is_temporary_unlock_allowed);
                        builder.add_end_condition_type(args.end_condition_type);
                        builder.finish()
                    }

                    #[inline]
                    pub fn serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(Contract::VT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                    Contract::VT_PUBLIC_KEY,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn nonce(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                    Contract::VT_NONCE,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn confirm_code(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                    Contract::VT_CONFIRM_CODE,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn end_condition_type(&self) -> EndCondition {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<EndCondition>(
                                    Contract::VT_END_CONDITION_TYPE,
                                    Some(EndCondition::NONE),
                                )
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn end_condition(&self) -> Option<flatbuffers::Table<'a>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                                    Contract::VT_END_CONDITION,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn webhooks(
                        &self,
                    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WebHook<'a>>>>
                    {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab.get::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WebHook>>,
                            >>(Contract::VT_WEBHOOKS, None)
                        }
                    }
                    #[inline]
                    pub fn is_temporary_unlock_allowed(&self) -> bool {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<bool>(Contract::VT_IS_TEMPORARY_UNLOCK_ALLOWED, Some(false))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn unlock_rules(&self) -> Option<TemporaryUnlockRules<'a>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<TemporaryUnlockRules>>(
                                    Contract::VT_UNLOCK_RULES,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn end_condition_as_time_end_condition(
                        &self,
                    ) -> Option<TimeEndCondition<'a>> {
                        if self.end_condition_type() == EndCondition::TimeEndCondition {
                            self.end_condition().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { TimeEndCondition::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn end_condition_as_when_isay_so(&self) -> Option<WhenISaySo<'a>> {
                        if self.end_condition_type() == EndCondition::WhenISaySo {
                            self.end_condition().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { WhenISaySo::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }
                }

                impl flatbuffers::Verifiable for Contract<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<u16>("serial_number", Self::VT_SERIAL_NUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("nonce", Self::VT_NONCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("confirm_code", Self::VT_CONFIRM_CODE, false)?
     .visit_union::<EndCondition, _>("end_condition_type", Self::VT_END_CONDITION_TYPE, "end_condition", Self::VT_END_CONDITION, false, |key, v, pos| {
        match key {
          EndCondition::TimeEndCondition => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TimeEndCondition>>("EndCondition::TimeEndCondition", pos),
          EndCondition::WhenISaySo => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WhenISaySo>>("EndCondition::WhenISaySo", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WebHook>>>>("webhooks", Self::VT_WEBHOOKS, false)?
     .visit_field::<bool>("is_temporary_unlock_allowed", Self::VT_IS_TEMPORARY_UNLOCK_ALLOWED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TemporaryUnlockRules>>("unlock_rules", Self::VT_UNLOCK_RULES, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct ContractArgs<'a> {
                    pub serial_number: u16,
                    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    pub nonce: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    pub confirm_code: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    pub end_condition_type: EndCondition,
                    pub end_condition: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
                    pub webhooks: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WebHook<'a>>>,
                        >,
                    >,
                    pub is_temporary_unlock_allowed: bool,
                    pub unlock_rules: Option<flatbuffers::WIPOffset<TemporaryUnlockRules<'a>>>,
                }
                impl<'a> Default for ContractArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        ContractArgs {
                            serial_number: 0,
                            public_key: None,
                            nonce: None,
                            confirm_code: None,
                            end_condition_type: EndCondition::NONE,
                            end_condition: None,
                            webhooks: None,
                            is_temporary_unlock_allowed: false,
                            unlock_rules: None,
                        }
                    }
                }

                pub struct ContractBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContractBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_serial_number(&mut self, serial_number: u16) {
                        self.fbb_
                            .push_slot::<u16>(Contract::VT_SERIAL_NUMBER, serial_number, 0);
                    }
                    #[inline]
                    pub fn add_public_key(
                        &mut self,
                        public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Contract::VT_PUBLIC_KEY,
                            public_key,
                        );
                    }
                    #[inline]
                    pub fn add_nonce(
                        &mut self,
                        nonce: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Contract::VT_NONCE,
                            nonce,
                        );
                    }
                    #[inline]
                    pub fn add_confirm_code(
                        &mut self,
                        confirm_code: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Contract::VT_CONFIRM_CODE,
                            confirm_code,
                        );
                    }
                    #[inline]
                    pub fn add_end_condition_type(&mut self, end_condition_type: EndCondition) {
                        self.fbb_.push_slot::<EndCondition>(
                            Contract::VT_END_CONDITION_TYPE,
                            end_condition_type,
                            EndCondition::NONE,
                        );
                    }
                    #[inline]
                    pub fn add_end_condition(
                        &mut self,
                        end_condition: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Contract::VT_END_CONDITION,
                            end_condition,
                        );
                    }
                    #[inline]
                    pub fn add_webhooks(
                        &mut self,
                        webhooks: flatbuffers::WIPOffset<
                            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<WebHook<'b>>>,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Contract::VT_WEBHOOKS,
                            webhooks,
                        );
                    }
                    #[inline]
                    pub fn add_is_temporary_unlock_allowed(
                        &mut self,
                        is_temporary_unlock_allowed: bool,
                    ) {
                        self.fbb_.push_slot::<bool>(
                            Contract::VT_IS_TEMPORARY_UNLOCK_ALLOWED,
                            is_temporary_unlock_allowed,
                            false,
                        );
                    }
                    #[inline]
                    pub fn add_unlock_rules(
                        &mut self,
                        unlock_rules: flatbuffers::WIPOffset<TemporaryUnlockRules<'b>>,
                    ) {
                        self.fbb_
                            .push_slot_always::<flatbuffers::WIPOffset<TemporaryUnlockRules>>(
                                Contract::VT_UNLOCK_RULES,
                                unlock_rules,
                            );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> ContractBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        ContractBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Contract<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for Contract<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("Contract");
                        ds.field("serial_number", &self.serial_number());
                        ds.field("public_key", &self.public_key());
                        ds.field("nonce", &self.nonce());
                        ds.field("confirm_code", &self.confirm_code());
                        ds.field("end_condition_type", &self.end_condition_type());
                        match self.end_condition_type() {
                            EndCondition::TimeEndCondition => {
                                if let Some(x) = self.end_condition_as_time_end_condition() {
                                    ds.field("end_condition", &x)
                                } else {
                                    ds.field("end_condition", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            EndCondition::WhenISaySo => {
                                if let Some(x) = self.end_condition_as_when_isay_so() {
                                    ds.field("end_condition", &x)
                                } else {
                                    ds.field("end_condition", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            _ => {
                                let x: Option<()> = None;
                                ds.field("end_condition", &x)
                            }
                        };
                        ds.field("webhooks", &self.webhooks());
                        ds.field(
                            "is_temporary_unlock_allowed",
                            &self.is_temporary_unlock_allowed(),
                        );
                        ds.field("unlock_rules", &self.unlock_rules());
                        ds.finish()
                    }
                }
                pub enum StartedUpdateOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct StartedUpdate<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for StartedUpdate<'a> {
                    type Inner = StartedUpdate<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> StartedUpdate<'a> {
                    pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
                    pub const VT_SESSION: flatbuffers::VOffsetT = 6;
                    pub const VT_STARTED_WITH_LOCAL_CONTRACT: flatbuffers::VOffsetT = 8;
                    pub const VT_CURRENT_CONTRACT_SERIAL: flatbuffers::VOffsetT = 10;
                    pub const VT_IS_LOCKED: flatbuffers::VOffsetT = 12;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        StartedUpdate { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args StartedUpdateArgs<'args>,
                    ) -> flatbuffers::WIPOffset<StartedUpdate<'bldr>> {
                        let mut builder = StartedUpdateBuilder::new(_fbb);
                        if let Some(x) = args.session {
                            builder.add_session(x);
                        }
                        if let Some(x) = args.public_key {
                            builder.add_public_key(x);
                        }
                        builder.add_current_contract_serial(args.current_contract_serial);
                        builder.add_is_locked(args.is_locked);
                        builder.add_started_with_local_contract(args.started_with_local_contract);
                        builder.finish()
                    }

                    #[inline]
                    pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                    StartedUpdate::VT_PUBLIC_KEY,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn session(&self) -> Option<&'a str> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                                StartedUpdate::VT_SESSION,
                                None,
                            )
                        }
                    }
                    #[inline]
                    pub fn started_with_local_contract(&self) -> bool {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<bool>(
                                    StartedUpdate::VT_STARTED_WITH_LOCAL_CONTRACT,
                                    Some(false),
                                )
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn current_contract_serial(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(StartedUpdate::VT_CURRENT_CONTRACT_SERIAL, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn is_locked(&self) -> bool {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<bool>(StartedUpdate::VT_IS_LOCKED, Some(false))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for StartedUpdate<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("session", Self::VT_SESSION, false)?
     .visit_field::<bool>("started_with_local_contract", Self::VT_STARTED_WITH_LOCAL_CONTRACT, false)?
     .visit_field::<u16>("current_contract_serial", Self::VT_CURRENT_CONTRACT_SERIAL, false)?
     .visit_field::<bool>("is_locked", Self::VT_IS_LOCKED, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct StartedUpdateArgs<'a> {
                    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    pub session: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub started_with_local_contract: bool,
                    pub current_contract_serial: u16,
                    pub is_locked: bool,
                }
                impl<'a> Default for StartedUpdateArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        StartedUpdateArgs {
                            public_key: None,
                            session: None,
                            started_with_local_contract: false,
                            current_contract_serial: 0,
                            is_locked: false,
                        }
                    }
                }

                pub struct StartedUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StartedUpdateBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_public_key(
                        &mut self,
                        public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            StartedUpdate::VT_PUBLIC_KEY,
                            public_key,
                        );
                    }
                    #[inline]
                    pub fn add_session(&mut self, session: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            StartedUpdate::VT_SESSION,
                            session,
                        );
                    }
                    #[inline]
                    pub fn add_started_with_local_contract(
                        &mut self,
                        started_with_local_contract: bool,
                    ) {
                        self.fbb_.push_slot::<bool>(
                            StartedUpdate::VT_STARTED_WITH_LOCAL_CONTRACT,
                            started_with_local_contract,
                            false,
                        );
                    }
                    #[inline]
                    pub fn add_current_contract_serial(&mut self, current_contract_serial: u16) {
                        self.fbb_.push_slot::<u16>(
                            StartedUpdate::VT_CURRENT_CONTRACT_SERIAL,
                            current_contract_serial,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_is_locked(&mut self, is_locked: bool) {
                        self.fbb_
                            .push_slot::<bool>(StartedUpdate::VT_IS_LOCKED, is_locked, false);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> StartedUpdateBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        StartedUpdateBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<StartedUpdate<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for StartedUpdate<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("StartedUpdate");
                        ds.field("public_key", &self.public_key());
                        ds.field("session", &self.session());
                        ds.field(
                            "started_with_local_contract",
                            &self.started_with_local_contract(),
                        );
                        ds.field("current_contract_serial", &self.current_contract_serial());
                        ds.field("is_locked", &self.is_locked());
                        ds.finish()
                    }
                }
                pub enum PeriodicUpdateOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct PeriodicUpdate<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for PeriodicUpdate<'a> {
                    type Inner = PeriodicUpdate<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> PeriodicUpdate<'a> {
                    pub const VT_SESSION: flatbuffers::VOffsetT = 4;
                    pub const VT_IS_LOCKED: flatbuffers::VOffsetT = 6;
                    pub const VT_CURRENT_CONTRACT_SERIAL: flatbuffers::VOffsetT = 8;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        PeriodicUpdate { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args PeriodicUpdateArgs<'args>,
                    ) -> flatbuffers::WIPOffset<PeriodicUpdate<'bldr>> {
                        let mut builder = PeriodicUpdateBuilder::new(_fbb);
                        if let Some(x) = args.session {
                            builder.add_session(x);
                        }
                        builder.add_current_contract_serial(args.current_contract_serial);
                        builder.add_is_locked(args.is_locked);
                        builder.finish()
                    }

                    #[inline]
                    pub fn session(&self) -> Option<&'a str> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                                PeriodicUpdate::VT_SESSION,
                                None,
                            )
                        }
                    }
                    #[inline]
                    pub fn is_locked(&self) -> bool {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<bool>(PeriodicUpdate::VT_IS_LOCKED, Some(false))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn current_contract_serial(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(PeriodicUpdate::VT_CURRENT_CONTRACT_SERIAL, Some(0))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for PeriodicUpdate<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                                "session",
                                Self::VT_SESSION,
                                false,
                            )?
                            .visit_field::<bool>("is_locked", Self::VT_IS_LOCKED, false)?
                            .visit_field::<u16>(
                                "current_contract_serial",
                                Self::VT_CURRENT_CONTRACT_SERIAL,
                                false,
                            )?
                            .finish();
                        Ok(())
                    }
                }
                pub struct PeriodicUpdateArgs<'a> {
                    pub session: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub is_locked: bool,
                    pub current_contract_serial: u16,
                }
                impl<'a> Default for PeriodicUpdateArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        PeriodicUpdateArgs {
                            session: None,
                            is_locked: false,
                            current_contract_serial: 0,
                        }
                    }
                }

                pub struct PeriodicUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PeriodicUpdateBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_session(&mut self, session: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            PeriodicUpdate::VT_SESSION,
                            session,
                        );
                    }
                    #[inline]
                    pub fn add_is_locked(&mut self, is_locked: bool) {
                        self.fbb_
                            .push_slot::<bool>(PeriodicUpdate::VT_IS_LOCKED, is_locked, false);
                    }
                    #[inline]
                    pub fn add_current_contract_serial(&mut self, current_contract_serial: u16) {
                        self.fbb_.push_slot::<u16>(
                            PeriodicUpdate::VT_CURRENT_CONTRACT_SERIAL,
                            current_contract_serial,
                            0,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> PeriodicUpdateBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        PeriodicUpdateBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<PeriodicUpdate<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for PeriodicUpdate<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("PeriodicUpdate");
                        ds.field("session", &self.session());
                        ds.field("is_locked", &self.is_locked());
                        ds.field("current_contract_serial", &self.current_contract_serial());
                        ds.finish()
                    }
                }
                pub enum AcknowledgementOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Acknowledgement<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Acknowledgement<'a> {
                    type Inner = Acknowledgement<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> Acknowledgement<'a> {
                    pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
                    pub const VT_SESSION: flatbuffers::VOffsetT = 6;
                    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 8;
                    pub const VT_COUNTER: flatbuffers::VOffsetT = 10;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Acknowledgement { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args AcknowledgementArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Acknowledgement<'bldr>> {
                        let mut builder = AcknowledgementBuilder::new(_fbb);
                        if let Some(x) = args.session {
                            builder.add_session(x);
                        }
                        if let Some(x) = args.public_key {
                            builder.add_public_key(x);
                        }
                        builder.add_counter(args.counter);
                        builder.add_serial_number(args.serial_number);
                        builder.finish()
                    }

                    #[inline]
                    pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                    Acknowledgement::VT_PUBLIC_KEY,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn session(&self) -> Option<&'a str> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                                Acknowledgement::VT_SESSION,
                                None,
                            )
                        }
                    }
                    #[inline]
                    pub fn serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(Acknowledgement::VT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn counter(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(Acknowledgement::VT_COUNTER, Some(0))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for Acknowledgement<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("session", Self::VT_SESSION, false)?
     .visit_field::<u16>("serial_number", Self::VT_SERIAL_NUMBER, false)?
     .visit_field::<u16>("counter", Self::VT_COUNTER, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct AcknowledgementArgs<'a> {
                    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    pub session: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub serial_number: u16,
                    pub counter: u16,
                }
                impl<'a> Default for AcknowledgementArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        AcknowledgementArgs {
                            public_key: None,
                            session: None,
                            serial_number: 0,
                            counter: 0,
                        }
                    }
                }

                pub struct AcknowledgementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AcknowledgementBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_public_key(
                        &mut self,
                        public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Acknowledgement::VT_PUBLIC_KEY,
                            public_key,
                        );
                    }
                    #[inline]
                    pub fn add_session(&mut self, session: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Acknowledgement::VT_SESSION,
                            session,
                        );
                    }
                    #[inline]
                    pub fn add_serial_number(&mut self, serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            Acknowledgement::VT_SERIAL_NUMBER,
                            serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_counter(&mut self, counter: u16) {
                        self.fbb_
                            .push_slot::<u16>(Acknowledgement::VT_COUNTER, counter, 0);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> AcknowledgementBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        AcknowledgementBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Acknowledgement<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for Acknowledgement<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("Acknowledgement");
                        ds.field("public_key", &self.public_key());
                        ds.field("session", &self.session());
                        ds.field("serial_number", &self.serial_number());
                        ds.field("counter", &self.counter());
                        ds.finish()
                    }
                }
                pub enum ErrorOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Error<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Error<'a> {
                    type Inner = Error<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> Error<'a> {
                    pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
                    pub const VT_SESSION: flatbuffers::VOffsetT = 6;
                    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 8;
                    pub const VT_COUNTER: flatbuffers::VOffsetT = 10;
                    pub const VT_MESSAGE: flatbuffers::VOffsetT = 12;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Error { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args ErrorArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Error<'bldr>> {
                        let mut builder = ErrorBuilder::new(_fbb);
                        if let Some(x) = args.message {
                            builder.add_message(x);
                        }
                        if let Some(x) = args.session {
                            builder.add_session(x);
                        }
                        if let Some(x) = args.public_key {
                            builder.add_public_key(x);
                        }
                        builder.add_counter(args.counter);
                        builder.add_serial_number(args.serial_number);
                        builder.finish()
                    }

                    #[inline]
                    pub fn public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                    Error::VT_PUBLIC_KEY,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn session(&self) -> Option<&'a str> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<&str>>(Error::VT_SESSION, None)
                        }
                    }
                    #[inline]
                    pub fn serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(Error::VT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn counter(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe { self._tab.get::<u16>(Error::VT_COUNTER, Some(0)).unwrap() }
                    }
                    #[inline]
                    pub fn message(&self) -> Option<&'a str> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<&str>>(Error::VT_MESSAGE, None)
                        }
                    }
                }

                impl flatbuffers::Verifiable for Error<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("session", Self::VT_SESSION, false)?
     .visit_field::<u16>("serial_number", Self::VT_SERIAL_NUMBER, false)?
     .visit_field::<u16>("counter", Self::VT_COUNTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct ErrorArgs<'a> {
                    pub public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    pub session: Option<flatbuffers::WIPOffset<&'a str>>,
                    pub serial_number: u16,
                    pub counter: u16,
                    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
                }
                impl<'a> Default for ErrorArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        ErrorArgs {
                            public_key: None,
                            session: None,
                            serial_number: 0,
                            counter: 0,
                            message: None,
                        }
                    }
                }

                pub struct ErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ErrorBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_public_key(
                        &mut self,
                        public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Error::VT_PUBLIC_KEY,
                            public_key,
                        );
                    }
                    #[inline]
                    pub fn add_session(&mut self, session: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Error::VT_SESSION,
                            session,
                        );
                    }
                    #[inline]
                    pub fn add_serial_number(&mut self, serial_number: u16) {
                        self.fbb_
                            .push_slot::<u16>(Error::VT_SERIAL_NUMBER, serial_number, 0);
                    }
                    #[inline]
                    pub fn add_counter(&mut self, counter: u16) {
                        self.fbb_.push_slot::<u16>(Error::VT_COUNTER, counter, 0);
                    }
                    #[inline]
                    pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Error::VT_MESSAGE,
                            message,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> ErrorBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        ErrorBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Error<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for Error<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("Error");
                        ds.field("public_key", &self.public_key());
                        ds.field("session", &self.session());
                        ds.field("serial_number", &self.serial_number());
                        ds.field("counter", &self.counter());
                        ds.field("message", &self.message());
                        ds.finish()
                    }
                }
                pub enum LockCommandOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct LockCommand<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for LockCommand<'a> {
                    type Inner = LockCommand<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> LockCommand<'a> {
                    pub const VT_CONTRACT_SERIAL_NUMBER: flatbuffers::VOffsetT = 4;
                    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 6;
                    pub const VT_COUNTER: flatbuffers::VOffsetT = 8;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        LockCommand { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args LockCommandArgs,
                    ) -> flatbuffers::WIPOffset<LockCommand<'bldr>> {
                        let mut builder = LockCommandBuilder::new(_fbb);
                        builder.add_counter(args.counter);
                        builder.add_serial_number(args.serial_number);
                        builder.add_contract_serial_number(args.contract_serial_number);
                        builder.finish()
                    }

                    #[inline]
                    pub fn contract_serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(LockCommand::VT_CONTRACT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(LockCommand::VT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn counter(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(LockCommand::VT_COUNTER, Some(0))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for LockCommand<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<u16>(
                                "contract_serial_number",
                                Self::VT_CONTRACT_SERIAL_NUMBER,
                                false,
                            )?
                            .visit_field::<u16>("serial_number", Self::VT_SERIAL_NUMBER, false)?
                            .visit_field::<u16>("counter", Self::VT_COUNTER, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct LockCommandArgs {
                    pub contract_serial_number: u16,
                    pub serial_number: u16,
                    pub counter: u16,
                }
                impl<'a> Default for LockCommandArgs {
                    #[inline]
                    fn default() -> Self {
                        LockCommandArgs {
                            contract_serial_number: 0,
                            serial_number: 0,
                            counter: 0,
                        }
                    }
                }

                pub struct LockCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LockCommandBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_contract_serial_number(&mut self, contract_serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            LockCommand::VT_CONTRACT_SERIAL_NUMBER,
                            contract_serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_serial_number(&mut self, serial_number: u16) {
                        self.fbb_
                            .push_slot::<u16>(LockCommand::VT_SERIAL_NUMBER, serial_number, 0);
                    }
                    #[inline]
                    pub fn add_counter(&mut self, counter: u16) {
                        self.fbb_
                            .push_slot::<u16>(LockCommand::VT_COUNTER, counter, 0);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> LockCommandBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        LockCommandBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<LockCommand<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for LockCommand<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("LockCommand");
                        ds.field("contract_serial_number", &self.contract_serial_number());
                        ds.field("serial_number", &self.serial_number());
                        ds.field("counter", &self.counter());
                        ds.finish()
                    }
                }
                pub enum UnlockCommandOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct UnlockCommand<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for UnlockCommand<'a> {
                    type Inner = UnlockCommand<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> UnlockCommand<'a> {
                    pub const VT_CONTRACT_SERIAL_NUMBER: flatbuffers::VOffsetT = 4;
                    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 6;
                    pub const VT_COUNTER: flatbuffers::VOffsetT = 8;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        UnlockCommand { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args UnlockCommandArgs,
                    ) -> flatbuffers::WIPOffset<UnlockCommand<'bldr>> {
                        let mut builder = UnlockCommandBuilder::new(_fbb);
                        builder.add_counter(args.counter);
                        builder.add_serial_number(args.serial_number);
                        builder.add_contract_serial_number(args.contract_serial_number);
                        builder.finish()
                    }

                    #[inline]
                    pub fn contract_serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(UnlockCommand::VT_CONTRACT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(UnlockCommand::VT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn counter(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(UnlockCommand::VT_COUNTER, Some(0))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for UnlockCommand<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<u16>(
                                "contract_serial_number",
                                Self::VT_CONTRACT_SERIAL_NUMBER,
                                false,
                            )?
                            .visit_field::<u16>("serial_number", Self::VT_SERIAL_NUMBER, false)?
                            .visit_field::<u16>("counter", Self::VT_COUNTER, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct UnlockCommandArgs {
                    pub contract_serial_number: u16,
                    pub serial_number: u16,
                    pub counter: u16,
                }
                impl<'a> Default for UnlockCommandArgs {
                    #[inline]
                    fn default() -> Self {
                        UnlockCommandArgs {
                            contract_serial_number: 0,
                            serial_number: 0,
                            counter: 0,
                        }
                    }
                }

                pub struct UnlockCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnlockCommandBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_contract_serial_number(&mut self, contract_serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            UnlockCommand::VT_CONTRACT_SERIAL_NUMBER,
                            contract_serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_serial_number(&mut self, serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            UnlockCommand::VT_SERIAL_NUMBER,
                            serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_counter(&mut self, counter: u16) {
                        self.fbb_
                            .push_slot::<u16>(UnlockCommand::VT_COUNTER, counter, 0);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> UnlockCommandBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        UnlockCommandBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<UnlockCommand<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for UnlockCommand<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("UnlockCommand");
                        ds.field("contract_serial_number", &self.contract_serial_number());
                        ds.field("serial_number", &self.serial_number());
                        ds.field("counter", &self.counter());
                        ds.finish()
                    }
                }
                pub enum ReleaseCommandOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct ReleaseCommand<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for ReleaseCommand<'a> {
                    type Inner = ReleaseCommand<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> ReleaseCommand<'a> {
                    pub const VT_CONTRACT_SERIAL_NUMBER: flatbuffers::VOffsetT = 4;
                    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 6;
                    pub const VT_COUNTER: flatbuffers::VOffsetT = 8;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        ReleaseCommand { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args ReleaseCommandArgs,
                    ) -> flatbuffers::WIPOffset<ReleaseCommand<'bldr>> {
                        let mut builder = ReleaseCommandBuilder::new(_fbb);
                        builder.add_counter(args.counter);
                        builder.add_serial_number(args.serial_number);
                        builder.add_contract_serial_number(args.contract_serial_number);
                        builder.finish()
                    }

                    #[inline]
                    pub fn contract_serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(ReleaseCommand::VT_CONTRACT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(ReleaseCommand::VT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn counter(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(ReleaseCommand::VT_COUNTER, Some(0))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for ReleaseCommand<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<u16>(
                                "contract_serial_number",
                                Self::VT_CONTRACT_SERIAL_NUMBER,
                                false,
                            )?
                            .visit_field::<u16>("serial_number", Self::VT_SERIAL_NUMBER, false)?
                            .visit_field::<u16>("counter", Self::VT_COUNTER, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct ReleaseCommandArgs {
                    pub contract_serial_number: u16,
                    pub serial_number: u16,
                    pub counter: u16,
                }
                impl<'a> Default for ReleaseCommandArgs {
                    #[inline]
                    fn default() -> Self {
                        ReleaseCommandArgs {
                            contract_serial_number: 0,
                            serial_number: 0,
                            counter: 0,
                        }
                    }
                }

                pub struct ReleaseCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReleaseCommandBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_contract_serial_number(&mut self, contract_serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            ReleaseCommand::VT_CONTRACT_SERIAL_NUMBER,
                            contract_serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_serial_number(&mut self, serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            ReleaseCommand::VT_SERIAL_NUMBER,
                            serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_counter(&mut self, counter: u16) {
                        self.fbb_
                            .push_slot::<u16>(ReleaseCommand::VT_COUNTER, counter, 0);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> ReleaseCommandBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        ReleaseCommandBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<ReleaseCommand<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for ReleaseCommand<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("ReleaseCommand");
                        ds.field("contract_serial_number", &self.contract_serial_number());
                        ds.field("serial_number", &self.serial_number());
                        ds.field("counter", &self.counter());
                        ds.finish()
                    }
                }
                pub enum AbortCommandOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct AbortCommand<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for AbortCommand<'a> {
                    type Inner = AbortCommand<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> AbortCommand<'a> {
                    pub const VT_CONTRACT_SERIAL_NUMBER: flatbuffers::VOffsetT = 4;
                    pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 6;
                    pub const VT_COUNTER: flatbuffers::VOffsetT = 8;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        AbortCommand { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args AbortCommandArgs,
                    ) -> flatbuffers::WIPOffset<AbortCommand<'bldr>> {
                        let mut builder = AbortCommandBuilder::new(_fbb);
                        builder.add_counter(args.counter);
                        builder.add_serial_number(args.serial_number);
                        builder.add_contract_serial_number(args.contract_serial_number);
                        builder.finish()
                    }

                    #[inline]
                    pub fn contract_serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(AbortCommand::VT_CONTRACT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn serial_number(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(AbortCommand::VT_SERIAL_NUMBER, Some(0))
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn counter(&self) -> u16 {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<u16>(AbortCommand::VT_COUNTER, Some(0))
                                .unwrap()
                        }
                    }
                }

                impl flatbuffers::Verifiable for AbortCommand<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<u16>(
                                "contract_serial_number",
                                Self::VT_CONTRACT_SERIAL_NUMBER,
                                false,
                            )?
                            .visit_field::<u16>("serial_number", Self::VT_SERIAL_NUMBER, false)?
                            .visit_field::<u16>("counter", Self::VT_COUNTER, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct AbortCommandArgs {
                    pub contract_serial_number: u16,
                    pub serial_number: u16,
                    pub counter: u16,
                }
                impl<'a> Default for AbortCommandArgs {
                    #[inline]
                    fn default() -> Self {
                        AbortCommandArgs {
                            contract_serial_number: 0,
                            serial_number: 0,
                            counter: 0,
                        }
                    }
                }

                pub struct AbortCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AbortCommandBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_contract_serial_number(&mut self, contract_serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            AbortCommand::VT_CONTRACT_SERIAL_NUMBER,
                            contract_serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_serial_number(&mut self, serial_number: u16) {
                        self.fbb_.push_slot::<u16>(
                            AbortCommand::VT_SERIAL_NUMBER,
                            serial_number,
                            0,
                        );
                    }
                    #[inline]
                    pub fn add_counter(&mut self, counter: u16) {
                        self.fbb_
                            .push_slot::<u16>(AbortCommand::VT_COUNTER, counter, 0);
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> AbortCommandBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        AbortCommandBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<AbortCommand<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for AbortCommand<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("AbortCommand");
                        ds.field("contract_serial_number", &self.contract_serial_number());
                        ds.field("serial_number", &self.serial_number());
                        ds.field("counter", &self.counter());
                        ds.finish()
                    }
                }
                pub enum SignedMessageOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct SignedMessage<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for SignedMessage<'a> {
                    type Inner = SignedMessage<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self {
                            _tab: flatbuffers::Table::new(buf, loc),
                        }
                    }
                }

                impl<'a> SignedMessage<'a> {
                    pub const VT_SIGNATURE: flatbuffers::VOffsetT = 4;
                    pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 6;
                    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 8;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        SignedMessage { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args SignedMessageArgs<'args>,
                    ) -> flatbuffers::WIPOffset<SignedMessage<'bldr>> {
                        let mut builder = SignedMessageBuilder::new(_fbb);
                        if let Some(x) = args.payload {
                            builder.add_payload(x);
                        }
                        if let Some(x) = args.signature {
                            builder.add_signature(x);
                        }
                        builder.add_payload_type(args.payload_type);
                        builder.finish()
                    }

                    #[inline]
                    pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                    SignedMessage::VT_SIGNATURE,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    pub fn payload_type(&self) -> MessagePayload {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<MessagePayload>(
                                    SignedMessage::VT_PAYLOAD_TYPE,
                                    Some(MessagePayload::NONE),
                                )
                                .unwrap()
                        }
                    }
                    #[inline]
                    pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                                    SignedMessage::VT_PAYLOAD,
                                    None,
                                )
                        }
                    }
                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_contract(&self) -> Option<Contract<'a>> {
                        if self.payload_type() == MessagePayload::Contract {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { Contract::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_lock_command(&self) -> Option<LockCommand<'a>> {
                        if self.payload_type() == MessagePayload::LockCommand {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { LockCommand::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_unlock_command(&self) -> Option<UnlockCommand<'a>> {
                        if self.payload_type() == MessagePayload::UnlockCommand {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { UnlockCommand::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_release_command(&self) -> Option<ReleaseCommand<'a>> {
                        if self.payload_type() == MessagePayload::ReleaseCommand {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { ReleaseCommand::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_started_update(&self) -> Option<StartedUpdate<'a>> {
                        if self.payload_type() == MessagePayload::StartedUpdate {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { StartedUpdate::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_periodic_update(&self) -> Option<PeriodicUpdate<'a>> {
                        if self.payload_type() == MessagePayload::PeriodicUpdate {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { PeriodicUpdate::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_acknowledgement(&self) -> Option<Acknowledgement<'a>> {
                        if self.payload_type() == MessagePayload::Acknowledgement {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { Acknowledgement::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_error(&self) -> Option<Error<'a>> {
                        if self.payload_type() == MessagePayload::Error {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { Error::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }

                    #[inline]
                    #[allow(non_snake_case)]
                    pub fn payload_as_abort_command(&self) -> Option<AbortCommand<'a>> {
                        if self.payload_type() == MessagePayload::AbortCommand {
                            self.payload().map(|t| {
                                // Safety:
                                // Created from a valid Table for this object
                                // Which contains a valid union in this slot
                                unsafe { AbortCommand::init_from_table(t) }
                            })
                        } else {
                            None
                        }
                    }
                }

                impl flatbuffers::Verifiable for SignedMessage<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier,
                        pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("signature", Self::VT_SIGNATURE, false)?
     .visit_union::<MessagePayload, _>("payload_type", Self::VT_PAYLOAD_TYPE, "payload", Self::VT_PAYLOAD, false, |key, v, pos| {
        match key {
          MessagePayload::Contract => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Contract>>("MessagePayload::Contract", pos),
          MessagePayload::LockCommand => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LockCommand>>("MessagePayload::LockCommand", pos),
          MessagePayload::UnlockCommand => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnlockCommand>>("MessagePayload::UnlockCommand", pos),
          MessagePayload::ReleaseCommand => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReleaseCommand>>("MessagePayload::ReleaseCommand", pos),
          MessagePayload::StartedUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StartedUpdate>>("MessagePayload::StartedUpdate", pos),
          MessagePayload::PeriodicUpdate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PeriodicUpdate>>("MessagePayload::PeriodicUpdate", pos),
          MessagePayload::Acknowledgement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Acknowledgement>>("MessagePayload::Acknowledgement", pos),
          MessagePayload::Error => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Error>>("MessagePayload::Error", pos),
          MessagePayload::AbortCommand => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AbortCommand>>("MessagePayload::AbortCommand", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                        Ok(())
                    }
                }
                pub struct SignedMessageArgs<'a> {
                    pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    pub payload_type: MessagePayload,
                    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
                }
                impl<'a> Default for SignedMessageArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        SignedMessageArgs {
                            signature: None,
                            payload_type: MessagePayload::NONE,
                            payload: None,
                        }
                    }
                }

                pub struct SignedMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SignedMessageBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_signature(
                        &mut self,
                        signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            SignedMessage::VT_SIGNATURE,
                            signature,
                        );
                    }
                    #[inline]
                    pub fn add_payload_type(&mut self, payload_type: MessagePayload) {
                        self.fbb_.push_slot::<MessagePayload>(
                            SignedMessage::VT_PAYLOAD_TYPE,
                            payload_type,
                            MessagePayload::NONE,
                        );
                    }
                    #[inline]
                    pub fn add_payload(
                        &mut self,
                        payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            SignedMessage::VT_PAYLOAD,
                            payload,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> SignedMessageBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        SignedMessageBuilder {
                            fbb_: _fbb,
                            start_: start,
                        }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<SignedMessage<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for SignedMessage<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("SignedMessage");
                        ds.field("signature", &self.signature());
                        ds.field("payload_type", &self.payload_type());
                        match self.payload_type() {
                            MessagePayload::Contract => {
                                if let Some(x) = self.payload_as_contract() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::LockCommand => {
                                if let Some(x) = self.payload_as_lock_command() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::UnlockCommand => {
                                if let Some(x) = self.payload_as_unlock_command() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::ReleaseCommand => {
                                if let Some(x) = self.payload_as_release_command() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::StartedUpdate => {
                                if let Some(x) = self.payload_as_started_update() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::PeriodicUpdate => {
                                if let Some(x) = self.payload_as_periodic_update() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::Acknowledgement => {
                                if let Some(x) = self.payload_as_acknowledgement() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::Error => {
                                if let Some(x) = self.payload_as_error() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            MessagePayload::AbortCommand => {
                                if let Some(x) = self.payload_as_abort_command() {
                                    ds.field("payload", &x)
                                } else {
                                    ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                }
                            }
                            _ => {
                                let x: Option<()> = None;
                                ds.field("payload", &x)
                            }
                        };
                        ds.finish()
                    }
                }
                #[inline]
                /// Verifies that a buffer of bytes contains a `SignedMessage`
                /// and returns it.
                /// Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `root_as_signed_message_unchecked`.
                pub fn root_as_signed_message(
                    buf: &[u8],
                ) -> Result<SignedMessage, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::root::<SignedMessage>(buf)
                }
                #[inline]
                /// Verifies that a buffer of bytes contains a size prefixed
                /// `SignedMessage` and returns it.
                /// Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `size_prefixed_root_as_signed_message_unchecked`.
                pub fn size_prefixed_root_as_signed_message(
                    buf: &[u8],
                ) -> Result<SignedMessage, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::size_prefixed_root::<SignedMessage>(buf)
                }
                #[inline]
                /// Verifies, with the given options, that a buffer of bytes
                /// contains a `SignedMessage` and returns it.
                /// Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `root_as_signed_message_unchecked`.
                pub fn root_as_signed_message_with_opts<'b, 'o>(
                    opts: &'o flatbuffers::VerifierOptions,
                    buf: &'b [u8],
                ) -> Result<SignedMessage<'b>, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::root_with_opts::<SignedMessage<'b>>(opts, buf)
                }
                #[inline]
                /// Verifies, with the given verifier options, that a buffer of
                /// bytes contains a size prefixed `SignedMessage` and returns
                /// it. Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `root_as_signed_message_unchecked`.
                pub fn size_prefixed_root_as_signed_message_with_opts<'b, 'o>(
                    opts: &'o flatbuffers::VerifierOptions,
                    buf: &'b [u8],
                ) -> Result<SignedMessage<'b>, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::size_prefixed_root_with_opts::<SignedMessage<'b>>(opts, buf)
                }
                #[inline]
                /// Assumes, without verification, that a buffer of bytes contains a SignedMessage and returns it.
                /// # Safety
                /// Callers must trust the given bytes do indeed contain a valid `SignedMessage`.
                pub unsafe fn root_as_signed_message_unchecked(buf: &[u8]) -> SignedMessage {
                    flatbuffers::root_unchecked::<SignedMessage>(buf)
                }
                #[inline]
                /// Assumes, without verification, that a buffer of bytes contains a size prefixed SignedMessage and returns it.
                /// # Safety
                /// Callers must trust the given bytes do indeed contain a valid size prefixed `SignedMessage`.
                pub unsafe fn size_prefixed_root_as_signed_message_unchecked(
                    buf: &[u8],
                ) -> SignedMessage {
                    flatbuffers::size_prefixed_root_unchecked::<SignedMessage>(buf)
                }
                #[inline]
                pub fn finish_signed_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
                    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    root: flatbuffers::WIPOffset<SignedMessage<'a>>,
                ) {
                    fbb.finish(root, None);
                }

                #[inline]
                pub fn finish_size_prefixed_signed_message_buffer<
                    'a,
                    'b,
                    A: flatbuffers::Allocator + 'a,
                >(
                    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    root: flatbuffers::WIPOffset<SignedMessage<'a>>,
                ) {
                    fbb.finish_size_prefixed(root, None);
                }
            } // pub mod message
        } // pub mod fb
    } // pub mod subjugated
} // pub mod club
