// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod club {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod subjugated {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};
        #[allow(unused_imports, dead_code)]
        pub mod fb {

            use core::cmp::Ordering;
            use core::mem;

            extern crate flatbuffers;
            use self::flatbuffers::{EndianScalar, Follow};
            #[allow(unused_imports, dead_code)]
            pub mod message {

                use core::cmp::Ordering;
                use core::mem;

                extern crate flatbuffers;
                use self::flatbuffers::{EndianScalar, Follow};
                #[allow(unused_imports, dead_code)]
                pub mod firmware {

                    use core::cmp::Ordering;
                    use core::mem;

                    extern crate flatbuffers;
                    use self::flatbuffers::{EndianScalar, Follow};

                    #[deprecated(
                        since = "2.0.0",
                        note = "Use associated constants instead. This will no longer be generated in 2021."
                    )]
                    pub const ENUM_MIN_MESSAGE_PAYLOAD: u8 = 0;
                    #[deprecated(
                        since = "2.0.0",
                        note = "Use associated constants instead. This will no longer be generated in 2021."
                    )]
                    pub const ENUM_MAX_MESSAGE_PAYLOAD: u8 = 6;
                    #[deprecated(
                        since = "2.0.0",
                        note = "Use associated constants instead. This will no longer be generated in 2021."
                    )]
                    #[allow(non_camel_case_types)]
                    pub const ENUM_VALUES_MESSAGE_PAYLOAD: [MessagePayload; 7] = [
                        MessagePayload::NONE,
                        MessagePayload::FirmwareChallengeRequest,
                        MessagePayload::FirmwareChallengeResponse,
                        MessagePayload::GetLatestFirmwareRequest,
                        MessagePayload::GetLatestFirmwareResponse,
                        MessagePayload::GetFirmwareChunkRequest,
                        MessagePayload::GetFirmwareChunkResponse,
                    ];

                    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
                    #[repr(transparent)]
                    pub struct MessagePayload(pub u8);
                    #[allow(non_upper_case_globals)]
                    impl MessagePayload {
                        pub const NONE: Self = Self(0);
                        pub const FirmwareChallengeRequest: Self = Self(1);
                        pub const FirmwareChallengeResponse: Self = Self(2);
                        pub const GetLatestFirmwareRequest: Self = Self(3);
                        pub const GetLatestFirmwareResponse: Self = Self(4);
                        pub const GetFirmwareChunkRequest: Self = Self(5);
                        pub const GetFirmwareChunkResponse: Self = Self(6);

                        pub const ENUM_MIN: u8 = 0;
                        pub const ENUM_MAX: u8 = 6;
                        pub const ENUM_VALUES: &'static [Self] = &[
                            Self::NONE,
                            Self::FirmwareChallengeRequest,
                            Self::FirmwareChallengeResponse,
                            Self::GetLatestFirmwareRequest,
                            Self::GetLatestFirmwareResponse,
                            Self::GetFirmwareChunkRequest,
                            Self::GetFirmwareChunkResponse,
                        ];
                        /// Returns the variant's name or "" if unknown.
                        pub fn variant_name(self) -> Option<&'static str> {
                            match self {
                                Self::NONE => Some("NONE"),
                                Self::FirmwareChallengeRequest => Some("FirmwareChallengeRequest"),
                                Self::FirmwareChallengeResponse => {
                                    Some("FirmwareChallengeResponse")
                                }
                                Self::GetLatestFirmwareRequest => Some("GetLatestFirmwareRequest"),
                                Self::GetLatestFirmwareResponse => {
                                    Some("GetLatestFirmwareResponse")
                                }
                                Self::GetFirmwareChunkRequest => Some("GetFirmwareChunkRequest"),
                                Self::GetFirmwareChunkResponse => Some("GetFirmwareChunkResponse"),
                                _ => None,
                            }
                        }
                    }
                    impl core::fmt::Debug for MessagePayload {
                        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                            if let Some(name) = self.variant_name() {
                                f.write_str(name)
                            } else {
                                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                            }
                        }
                    }
                    impl<'a> flatbuffers::Follow<'a> for MessagePayload {
                        type Inner = Self;
                        #[inline]
                        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                            Self(b)
                        }
                    }

                    impl flatbuffers::Push for MessagePayload {
                        type Output = MessagePayload;
                        #[inline]
                        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                            flatbuffers::emplace_scalar::<u8>(dst, self.0);
                        }
                    }

                    impl flatbuffers::EndianScalar for MessagePayload {
                        type Scalar = u8;
                        #[inline]
                        fn to_little_endian(self) -> u8 {
                            self.0.to_le()
                        }
                        #[inline]
                        #[allow(clippy::wrong_self_convention)]
                        fn from_little_endian(v: u8) -> Self {
                            let b = u8::from_le(v);
                            Self(b)
                        }
                    }

                    impl<'a> flatbuffers::Verifiable for MessagePayload {
                        #[inline]
                        fn run_verifier(
                            v: &mut flatbuffers::Verifier,
                            pos: usize,
                        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                            use self::flatbuffers::Verifiable;
                            u8::run_verifier(v, pos)
                        }
                    }

                    impl flatbuffers::SimpleToVerifyInSlice for MessagePayload {}
                    pub struct MessagePayloadUnionTableOffset {}

                    pub enum VersionOffset {}
                    #[derive(Copy, Clone, PartialEq)]

                    pub struct Version<'a> {
                        pub _tab: flatbuffers::Table<'a>,
                    }

                    impl<'a> flatbuffers::Follow<'a> for Version<'a> {
                        type Inner = Version<'a>;
                        #[inline]
                        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                            Self {
                                _tab: flatbuffers::Table::new(buf, loc),
                            }
                        }
                    }

                    impl<'a> Version<'a> {
                        pub const VT_NAME: flatbuffers::VOffsetT = 4;
                        pub const VT_MAJOR: flatbuffers::VOffsetT = 6;
                        pub const VT_MINOR: flatbuffers::VOffsetT = 8;
                        pub const VT_BUILD: flatbuffers::VOffsetT = 10;
                        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 12;

                        #[inline]
                        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                            Version { _tab: table }
                        }
                        #[allow(unused_mut)]
                        pub fn create<
                            'bldr: 'args,
                            'args: 'mut_bldr,
                            'mut_bldr,
                            A: flatbuffers::Allocator + 'bldr,
                        >(
                            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                            args: &'args VersionArgs<'args>,
                        ) -> flatbuffers::WIPOffset<Version<'bldr>> {
                            let mut builder = VersionBuilder::new(_fbb);
                            if let Some(x) = args.signature {
                                builder.add_signature(x);
                            }
                            if let Some(x) = args.name {
                                builder.add_name(x);
                            }
                            builder.add_build(args.build);
                            builder.add_minor(args.minor);
                            builder.add_major(args.major);
                            builder.finish()
                        }

                        #[inline]
                        pub fn name(&self) -> Option<&'a str> {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                                    Version::VT_NAME,
                                    None,
                                )
                            }
                        }
                        #[inline]
                        pub fn major(&self) -> u16 {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe { self._tab.get::<u16>(Version::VT_MAJOR, Some(0)).unwrap() }
                        }
                        #[inline]
                        pub fn minor(&self) -> u16 {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe { self._tab.get::<u16>(Version::VT_MINOR, Some(0)).unwrap() }
                        }
                        #[inline]
                        pub fn build(&self) -> u16 {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe { self._tab.get::<u16>(Version::VT_BUILD, Some(0)).unwrap() }
                        }
                        #[inline]
                        pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Version::VT_SIGNATURE, None)
                            }
                        }
                    }

                    impl flatbuffers::Verifiable for Version<'_> {
                        #[inline]
                        fn run_verifier(
                            v: &mut flatbuffers::Verifier,
                            pos: usize,
                        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                            use self::flatbuffers::Verifiable;
                            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u16>("major", Self::VT_MAJOR, false)?
     .visit_field::<u16>("minor", Self::VT_MINOR, false)?
     .visit_field::<u16>("build", Self::VT_BUILD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("signature", Self::VT_SIGNATURE, false)?
     .finish();
                            Ok(())
                        }
                    }
                    pub struct VersionArgs<'a> {
                        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
                        pub major: u16,
                        pub minor: u16,
                        pub build: u16,
                        pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    }
                    impl<'a> Default for VersionArgs<'a> {
                        #[inline]
                        fn default() -> Self {
                            VersionArgs {
                                name: None,
                                major: 0,
                                minor: 0,
                                build: 0,
                                signature: None,
                            }
                        }
                    }

                    pub struct VersionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                    }
                    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VersionBuilder<'a, 'b, A> {
                        #[inline]
                        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                                Version::VT_NAME,
                                name,
                            );
                        }
                        #[inline]
                        pub fn add_major(&mut self, major: u16) {
                            self.fbb_.push_slot::<u16>(Version::VT_MAJOR, major, 0);
                        }
                        #[inline]
                        pub fn add_minor(&mut self, minor: u16) {
                            self.fbb_.push_slot::<u16>(Version::VT_MINOR, minor, 0);
                        }
                        #[inline]
                        pub fn add_build(&mut self, build: u16) {
                            self.fbb_.push_slot::<u16>(Version::VT_BUILD, build, 0);
                        }
                        #[inline]
                        pub fn add_signature(
                            &mut self,
                            signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                        ) {
                            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                                Version::VT_SIGNATURE,
                                signature,
                            );
                        }
                        #[inline]
                        pub fn new(
                            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        ) -> VersionBuilder<'a, 'b, A> {
                            let start = _fbb.start_table();
                            VersionBuilder {
                                fbb_: _fbb,
                                start_: start,
                            }
                        }
                        #[inline]
                        pub fn finish(self) -> flatbuffers::WIPOffset<Version<'a>> {
                            let o = self.fbb_.end_table(self.start_);
                            flatbuffers::WIPOffset::new(o.value())
                        }
                    }

                    impl core::fmt::Debug for Version<'_> {
                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                            let mut ds = f.debug_struct("Version");
                            ds.field("name", &self.name());
                            ds.field("major", &self.major());
                            ds.field("minor", &self.minor());
                            ds.field("build", &self.build());
                            ds.field("signature", &self.signature());
                            ds.finish()
                        }
                    }
                    pub enum FirmwareChallengeRequestOffset {}
                    #[derive(Copy, Clone, PartialEq)]

                    pub struct FirmwareChallengeRequest<'a> {
                        pub _tab: flatbuffers::Table<'a>,
                    }

                    impl<'a> flatbuffers::Follow<'a> for FirmwareChallengeRequest<'a> {
                        type Inner = FirmwareChallengeRequest<'a>;
                        #[inline]
                        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                            Self {
                                _tab: flatbuffers::Table::new(buf, loc),
                            }
                        }
                    }

                    impl<'a> FirmwareChallengeRequest<'a> {
                        pub const VT_NONCE: flatbuffers::VOffsetT = 4;
                        pub const VT_LATEST: flatbuffers::VOffsetT = 6;

                        #[inline]
                        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                            FirmwareChallengeRequest { _tab: table }
                        }
                        #[allow(unused_mut)]
                        pub fn create<
                            'bldr: 'args,
                            'args: 'mut_bldr,
                            'mut_bldr,
                            A: flatbuffers::Allocator + 'bldr,
                        >(
                            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                            args: &'args FirmwareChallengeRequestArgs<'args>,
                        ) -> flatbuffers::WIPOffset<FirmwareChallengeRequest<'bldr>>
                        {
                            let mut builder = FirmwareChallengeRequestBuilder::new(_fbb);
                            if let Some(x) = args.latest {
                                builder.add_latest(x);
                            }
                            if let Some(x) = args.nonce {
                                builder.add_nonce(x);
                            }
                            builder.finish()
                        }

                        #[inline]
                        pub fn nonce(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(FirmwareChallengeRequest::VT_NONCE, None)
                            }
                        }
                        #[inline]
                        pub fn latest(&self) -> Option<Version<'a>> {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab.get::<flatbuffers::ForwardsUOffset<Version>>(
                                    FirmwareChallengeRequest::VT_LATEST,
                                    None,
                                )
                            }
                        }
                    }

                    impl flatbuffers::Verifiable for FirmwareChallengeRequest<'_> {
                        #[inline]
                        fn run_verifier(
                            v: &mut flatbuffers::Verifier,
                            pos: usize,
                        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                            use self::flatbuffers::Verifiable;
                            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("nonce", Self::VT_NONCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Version>>("latest", Self::VT_LATEST, false)?
     .finish();
                            Ok(())
                        }
                    }
                    pub struct FirmwareChallengeRequestArgs<'a> {
                        pub nonce: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                        pub latest: Option<flatbuffers::WIPOffset<Version<'a>>>,
                    }
                    impl<'a> Default for FirmwareChallengeRequestArgs<'a> {
                        #[inline]
                        fn default() -> Self {
                            FirmwareChallengeRequestArgs {
                                nonce: None,
                                latest: None,
                            }
                        }
                    }

                    pub struct FirmwareChallengeRequestBuilder<
                        'a: 'b,
                        'b,
                        A: flatbuffers::Allocator + 'a,
                    > {
                        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                    }
                    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FirmwareChallengeRequestBuilder<'a, 'b, A> {
                        #[inline]
                        pub fn add_nonce(
                            &mut self,
                            nonce: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                        ) {
                            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                                FirmwareChallengeRequest::VT_NONCE,
                                nonce,
                            );
                        }
                        #[inline]
                        pub fn add_latest(&mut self, latest: flatbuffers::WIPOffset<Version<'b>>) {
                            self.fbb_
                                .push_slot_always::<flatbuffers::WIPOffset<Version>>(
                                    FirmwareChallengeRequest::VT_LATEST,
                                    latest,
                                );
                        }
                        #[inline]
                        pub fn new(
                            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        ) -> FirmwareChallengeRequestBuilder<'a, 'b, A> {
                            let start = _fbb.start_table();
                            FirmwareChallengeRequestBuilder {
                                fbb_: _fbb,
                                start_: start,
                            }
                        }
                        #[inline]
                        pub fn finish(
                            self,
                        ) -> flatbuffers::WIPOffset<FirmwareChallengeRequest<'a>>
                        {
                            let o = self.fbb_.end_table(self.start_);
                            flatbuffers::WIPOffset::new(o.value())
                        }
                    }

                    impl core::fmt::Debug for FirmwareChallengeRequest<'_> {
                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                            let mut ds = f.debug_struct("FirmwareChallengeRequest");
                            ds.field("nonce", &self.nonce());
                            ds.field("latest", &self.latest());
                            ds.finish()
                        }
                    }
                    pub enum FirmwareChallengeResponseOffset {}
                    #[derive(Copy, Clone, PartialEq)]

                    pub struct FirmwareChallengeResponse<'a> {
                        pub _tab: flatbuffers::Table<'a>,
                    }

                    impl<'a> flatbuffers::Follow<'a> for FirmwareChallengeResponse<'a> {
                        type Inner = FirmwareChallengeResponse<'a>;
                        #[inline]
                        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                            Self {
                                _tab: flatbuffers::Table::new(buf, loc),
                            }
                        }
                    }

                    impl<'a> FirmwareChallengeResponse<'a> {
                        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 4;
                        pub const VT_VERSION: flatbuffers::VOffsetT = 6;

                        #[inline]
                        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                            FirmwareChallengeResponse { _tab: table }
                        }
                        #[allow(unused_mut)]
                        pub fn create<
                            'bldr: 'args,
                            'args: 'mut_bldr,
                            'mut_bldr,
                            A: flatbuffers::Allocator + 'bldr,
                        >(
                            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                            args: &'args FirmwareChallengeResponseArgs<'args>,
                        ) -> flatbuffers::WIPOffset<FirmwareChallengeResponse<'bldr>>
                        {
                            let mut builder = FirmwareChallengeResponseBuilder::new(_fbb);
                            if let Some(x) = args.version {
                                builder.add_version(x);
                            }
                            if let Some(x) = args.signature {
                                builder.add_signature(x);
                            }
                            builder.finish()
                        }

                        #[inline]
                        pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(FirmwareChallengeResponse::VT_SIGNATURE, None)
                            }
                        }
                        #[inline]
                        pub fn version(&self) -> Option<Version<'a>> {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab.get::<flatbuffers::ForwardsUOffset<Version>>(
                                    FirmwareChallengeResponse::VT_VERSION,
                                    None,
                                )
                            }
                        }
                    }

                    impl flatbuffers::Verifiable for FirmwareChallengeResponse<'_> {
                        #[inline]
                        fn run_verifier(
                            v: &mut flatbuffers::Verifier,
                            pos: usize,
                        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                            use self::flatbuffers::Verifiable;
                            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("signature", Self::VT_SIGNATURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Version>>("version", Self::VT_VERSION, false)?
     .finish();
                            Ok(())
                        }
                    }
                    pub struct FirmwareChallengeResponseArgs<'a> {
                        pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                        pub version: Option<flatbuffers::WIPOffset<Version<'a>>>,
                    }
                    impl<'a> Default for FirmwareChallengeResponseArgs<'a> {
                        #[inline]
                        fn default() -> Self {
                            FirmwareChallengeResponseArgs {
                                signature: None,
                                version: None,
                            }
                        }
                    }

                    pub struct FirmwareChallengeResponseBuilder<
                        'a: 'b,
                        'b,
                        A: flatbuffers::Allocator + 'a,
                    > {
                        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                    }
                    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FirmwareChallengeResponseBuilder<'a, 'b, A> {
                        #[inline]
                        pub fn add_signature(
                            &mut self,
                            signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                        ) {
                            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                                FirmwareChallengeResponse::VT_SIGNATURE,
                                signature,
                            );
                        }
                        #[inline]
                        pub fn add_version(
                            &mut self,
                            version: flatbuffers::WIPOffset<Version<'b>>,
                        ) {
                            self.fbb_
                                .push_slot_always::<flatbuffers::WIPOffset<Version>>(
                                    FirmwareChallengeResponse::VT_VERSION,
                                    version,
                                );
                        }
                        #[inline]
                        pub fn new(
                            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        ) -> FirmwareChallengeResponseBuilder<'a, 'b, A> {
                            let start = _fbb.start_table();
                            FirmwareChallengeResponseBuilder {
                                fbb_: _fbb,
                                start_: start,
                            }
                        }
                        #[inline]
                        pub fn finish(
                            self,
                        ) -> flatbuffers::WIPOffset<FirmwareChallengeResponse<'a>>
                        {
                            let o = self.fbb_.end_table(self.start_);
                            flatbuffers::WIPOffset::new(o.value())
                        }
                    }

                    impl core::fmt::Debug for FirmwareChallengeResponse<'_> {
                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                            let mut ds = f.debug_struct("FirmwareChallengeResponse");
                            ds.field("signature", &self.signature());
                            ds.field("version", &self.version());
                            ds.finish()
                        }
                    }
                    pub enum GetLatestFirmwareRequestOffset {}
                    #[derive(Copy, Clone, PartialEq)]

                    pub struct GetLatestFirmwareRequest<'a> {
                        pub _tab: flatbuffers::Table<'a>,
                    }

                    impl<'a> flatbuffers::Follow<'a> for GetLatestFirmwareRequest<'a> {
                        type Inner = GetLatestFirmwareRequest<'a>;
                        #[inline]
                        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                            Self {
                                _tab: flatbuffers::Table::new(buf, loc),
                            }
                        }
                    }

                    impl<'a> GetLatestFirmwareRequest<'a> {
                        pub const VT_VERSION: flatbuffers::VOffsetT = 4;

                        #[inline]
                        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                            GetLatestFirmwareRequest { _tab: table }
                        }
                        #[allow(unused_mut)]
                        pub fn create<
                            'bldr: 'args,
                            'args: 'mut_bldr,
                            'mut_bldr,
                            A: flatbuffers::Allocator + 'bldr,
                        >(
                            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                            args: &'args GetLatestFirmwareRequestArgs<'args>,
                        ) -> flatbuffers::WIPOffset<GetLatestFirmwareRequest<'bldr>>
                        {
                            let mut builder = GetLatestFirmwareRequestBuilder::new(_fbb);
                            if let Some(x) = args.version {
                                builder.add_version(x);
                            }
                            builder.finish()
                        }

                        #[inline]
                        pub fn version(&self) -> Option<Version<'a>> {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab.get::<flatbuffers::ForwardsUOffset<Version>>(
                                    GetLatestFirmwareRequest::VT_VERSION,
                                    None,
                                )
                            }
                        }
                    }

                    impl flatbuffers::Verifiable for GetLatestFirmwareRequest<'_> {
                        #[inline]
                        fn run_verifier(
                            v: &mut flatbuffers::Verifier,
                            pos: usize,
                        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                            use self::flatbuffers::Verifiable;
                            v.visit_table(pos)?
                                .visit_field::<flatbuffers::ForwardsUOffset<Version>>(
                                    "version",
                                    Self::VT_VERSION,
                                    false,
                                )?
                                .finish();
                            Ok(())
                        }
                    }
                    pub struct GetLatestFirmwareRequestArgs<'a> {
                        pub version: Option<flatbuffers::WIPOffset<Version<'a>>>,
                    }
                    impl<'a> Default for GetLatestFirmwareRequestArgs<'a> {
                        #[inline]
                        fn default() -> Self {
                            GetLatestFirmwareRequestArgs { version: None }
                        }
                    }

                    pub struct GetLatestFirmwareRequestBuilder<
                        'a: 'b,
                        'b,
                        A: flatbuffers::Allocator + 'a,
                    > {
                        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                    }
                    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetLatestFirmwareRequestBuilder<'a, 'b, A> {
                        #[inline]
                        pub fn add_version(
                            &mut self,
                            version: flatbuffers::WIPOffset<Version<'b>>,
                        ) {
                            self.fbb_
                                .push_slot_always::<flatbuffers::WIPOffset<Version>>(
                                    GetLatestFirmwareRequest::VT_VERSION,
                                    version,
                                );
                        }
                        #[inline]
                        pub fn new(
                            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        ) -> GetLatestFirmwareRequestBuilder<'a, 'b, A> {
                            let start = _fbb.start_table();
                            GetLatestFirmwareRequestBuilder {
                                fbb_: _fbb,
                                start_: start,
                            }
                        }
                        #[inline]
                        pub fn finish(
                            self,
                        ) -> flatbuffers::WIPOffset<GetLatestFirmwareRequest<'a>>
                        {
                            let o = self.fbb_.end_table(self.start_);
                            flatbuffers::WIPOffset::new(o.value())
                        }
                    }

                    impl core::fmt::Debug for GetLatestFirmwareRequest<'_> {
                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                            let mut ds = f.debug_struct("GetLatestFirmwareRequest");
                            ds.field("version", &self.version());
                            ds.finish()
                        }
                    }
                    pub enum GetLatestFirmwareResponseOffset {}
                    #[derive(Copy, Clone, PartialEq)]

                    pub struct GetLatestFirmwareResponse<'a> {
                        pub _tab: flatbuffers::Table<'a>,
                    }

                    impl<'a> flatbuffers::Follow<'a> for GetLatestFirmwareResponse<'a> {
                        type Inner = GetLatestFirmwareResponse<'a>;
                        #[inline]
                        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                            Self {
                                _tab: flatbuffers::Table::new(buf, loc),
                            }
                        }
                    }

                    impl<'a> GetLatestFirmwareResponse<'a> {
                        pub const VT_FIRMWARE: flatbuffers::VOffsetT = 4;
                        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 6;
                        pub const VT_VERSION: flatbuffers::VOffsetT = 8;
                        pub const VT_NAME: flatbuffers::VOffsetT = 10;
                        pub const VT_SIZE_: flatbuffers::VOffsetT = 12;

                        #[inline]
                        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                            GetLatestFirmwareResponse { _tab: table }
                        }
                        #[allow(unused_mut)]
                        pub fn create<
                            'bldr: 'args,
                            'args: 'mut_bldr,
                            'mut_bldr,
                            A: flatbuffers::Allocator + 'bldr,
                        >(
                            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                            args: &'args GetLatestFirmwareResponseArgs<'args>,
                        ) -> flatbuffers::WIPOffset<GetLatestFirmwareResponse<'bldr>>
                        {
                            let mut builder = GetLatestFirmwareResponseBuilder::new(_fbb);
                            if let Some(x) = args.name {
                                builder.add_name(x);
                            }
                            if let Some(x) = args.version {
                                builder.add_version(x);
                            }
                            if let Some(x) = args.signature {
                                builder.add_signature(x);
                            }
                            if let Some(x) = args.firmware {
                                builder.add_firmware(x);
                            }
                            builder.add_size_(args.size_);
                            builder.finish()
                        }

                        #[inline]
                        pub fn firmware(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GetLatestFirmwareResponse::VT_FIRMWARE, None)
                            }
                        }
                        #[inline]
                        pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GetLatestFirmwareResponse::VT_SIGNATURE, None)
                            }
                        }
                        #[inline]
                        pub fn version(&self) -> Option<Version<'a>> {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab.get::<flatbuffers::ForwardsUOffset<Version>>(
                                    GetLatestFirmwareResponse::VT_VERSION,
                                    None,
                                )
                            }
                        }
                        #[inline]
                        pub fn name(&self) -> Option<&'a str> {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                                    GetLatestFirmwareResponse::VT_NAME,
                                    None,
                                )
                            }
                        }
                        #[inline]
                        pub fn size_(&self) -> u16 {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab
                                    .get::<u16>(GetLatestFirmwareResponse::VT_SIZE_, Some(0))
                                    .unwrap()
                            }
                        }
                    }

                    impl flatbuffers::Verifiable for GetLatestFirmwareResponse<'_> {
                        #[inline]
                        fn run_verifier(
                            v: &mut flatbuffers::Verifier,
                            pos: usize,
                        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                            use self::flatbuffers::Verifiable;
                            v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("firmware", Self::VT_FIRMWARE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("signature", Self::VT_SIGNATURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Version>>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u16>("size_", Self::VT_SIZE_, false)?
     .finish();
                            Ok(())
                        }
                    }
                    pub struct GetLatestFirmwareResponseArgs<'a> {
                        pub firmware: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                        pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                        pub version: Option<flatbuffers::WIPOffset<Version<'a>>>,
                        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
                        pub size_: u16,
                    }
                    impl<'a> Default for GetLatestFirmwareResponseArgs<'a> {
                        #[inline]
                        fn default() -> Self {
                            GetLatestFirmwareResponseArgs {
                                firmware: None,
                                signature: None,
                                version: None,
                                name: None,
                                size_: 0,
                            }
                        }
                    }

                    pub struct GetLatestFirmwareResponseBuilder<
                        'a: 'b,
                        'b,
                        A: flatbuffers::Allocator + 'a,
                    > {
                        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                    }
                    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetLatestFirmwareResponseBuilder<'a, 'b, A> {
                        #[inline]
                        pub fn add_firmware(
                            &mut self,
                            firmware: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                        ) {
                            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                                GetLatestFirmwareResponse::VT_FIRMWARE,
                                firmware,
                            );
                        }
                        #[inline]
                        pub fn add_signature(
                            &mut self,
                            signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                        ) {
                            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                                GetLatestFirmwareResponse::VT_SIGNATURE,
                                signature,
                            );
                        }
                        #[inline]
                        pub fn add_version(
                            &mut self,
                            version: flatbuffers::WIPOffset<Version<'b>>,
                        ) {
                            self.fbb_
                                .push_slot_always::<flatbuffers::WIPOffset<Version>>(
                                    GetLatestFirmwareResponse::VT_VERSION,
                                    version,
                                );
                        }
                        #[inline]
                        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                                GetLatestFirmwareResponse::VT_NAME,
                                name,
                            );
                        }
                        #[inline]
                        pub fn add_size_(&mut self, size_: u16) {
                            self.fbb_.push_slot::<u16>(
                                GetLatestFirmwareResponse::VT_SIZE_,
                                size_,
                                0,
                            );
                        }
                        #[inline]
                        pub fn new(
                            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        ) -> GetLatestFirmwareResponseBuilder<'a, 'b, A> {
                            let start = _fbb.start_table();
                            GetLatestFirmwareResponseBuilder {
                                fbb_: _fbb,
                                start_: start,
                            }
                        }
                        #[inline]
                        pub fn finish(
                            self,
                        ) -> flatbuffers::WIPOffset<GetLatestFirmwareResponse<'a>>
                        {
                            let o = self.fbb_.end_table(self.start_);
                            flatbuffers::WIPOffset::new(o.value())
                        }
                    }

                    impl core::fmt::Debug for GetLatestFirmwareResponse<'_> {
                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                            let mut ds = f.debug_struct("GetLatestFirmwareResponse");
                            ds.field("firmware", &self.firmware());
                            ds.field("signature", &self.signature());
                            ds.field("version", &self.version());
                            ds.field("name", &self.name());
                            ds.field("size_", &self.size_());
                            ds.finish()
                        }
                    }
                    pub enum GetFirmwareChunkRequestOffset {}
                    #[derive(Copy, Clone, PartialEq)]

                    pub struct GetFirmwareChunkRequest<'a> {
                        pub _tab: flatbuffers::Table<'a>,
                    }

                    impl<'a> flatbuffers::Follow<'a> for GetFirmwareChunkRequest<'a> {
                        type Inner = GetFirmwareChunkRequest<'a>;
                        #[inline]
                        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                            Self {
                                _tab: flatbuffers::Table::new(buf, loc),
                            }
                        }
                    }

                    impl<'a> GetFirmwareChunkRequest<'a> {
                        pub const VT_NAME: flatbuffers::VOffsetT = 4;
                        pub const VT_OFFSET: flatbuffers::VOffsetT = 6;
                        pub const VT_SIZE_: flatbuffers::VOffsetT = 8;

                        #[inline]
                        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                            GetFirmwareChunkRequest { _tab: table }
                        }
                        #[allow(unused_mut)]
                        pub fn create<
                            'bldr: 'args,
                            'args: 'mut_bldr,
                            'mut_bldr,
                            A: flatbuffers::Allocator + 'bldr,
                        >(
                            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                            args: &'args GetFirmwareChunkRequestArgs<'args>,
                        ) -> flatbuffers::WIPOffset<GetFirmwareChunkRequest<'bldr>>
                        {
                            let mut builder = GetFirmwareChunkRequestBuilder::new(_fbb);
                            if let Some(x) = args.name {
                                builder.add_name(x);
                            }
                            builder.add_size_(args.size_);
                            builder.add_offset(args.offset);
                            builder.finish()
                        }

                        #[inline]
                        pub fn name(&self) -> Option<&'a str> {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                                    GetFirmwareChunkRequest::VT_NAME,
                                    None,
                                )
                            }
                        }
                        #[inline]
                        pub fn offset(&self) -> u16 {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab
                                    .get::<u16>(GetFirmwareChunkRequest::VT_OFFSET, Some(0))
                                    .unwrap()
                            }
                        }
                        #[inline]
                        pub fn size_(&self) -> u16 {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab
                                    .get::<u16>(GetFirmwareChunkRequest::VT_SIZE_, Some(0))
                                    .unwrap()
                            }
                        }
                    }

                    impl flatbuffers::Verifiable for GetFirmwareChunkRequest<'_> {
                        #[inline]
                        fn run_verifier(
                            v: &mut flatbuffers::Verifier,
                            pos: usize,
                        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                            use self::flatbuffers::Verifiable;
                            v.visit_table(pos)?
                                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                                    "name",
                                    Self::VT_NAME,
                                    false,
                                )?
                                .visit_field::<u16>("offset", Self::VT_OFFSET, false)?
                                .visit_field::<u16>("size_", Self::VT_SIZE_, false)?
                                .finish();
                            Ok(())
                        }
                    }
                    pub struct GetFirmwareChunkRequestArgs<'a> {
                        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
                        pub offset: u16,
                        pub size_: u16,
                    }
                    impl<'a> Default for GetFirmwareChunkRequestArgs<'a> {
                        #[inline]
                        fn default() -> Self {
                            GetFirmwareChunkRequestArgs {
                                name: None,
                                offset: 0,
                                size_: 0,
                            }
                        }
                    }

                    pub struct GetFirmwareChunkRequestBuilder<
                        'a: 'b,
                        'b,
                        A: flatbuffers::Allocator + 'a,
                    > {
                        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                    }
                    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetFirmwareChunkRequestBuilder<'a, 'b, A> {
                        #[inline]
                        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                                GetFirmwareChunkRequest::VT_NAME,
                                name,
                            );
                        }
                        #[inline]
                        pub fn add_offset(&mut self, offset: u16) {
                            self.fbb_.push_slot::<u16>(
                                GetFirmwareChunkRequest::VT_OFFSET,
                                offset,
                                0,
                            );
                        }
                        #[inline]
                        pub fn add_size_(&mut self, size_: u16) {
                            self.fbb_
                                .push_slot::<u16>(GetFirmwareChunkRequest::VT_SIZE_, size_, 0);
                        }
                        #[inline]
                        pub fn new(
                            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        ) -> GetFirmwareChunkRequestBuilder<'a, 'b, A> {
                            let start = _fbb.start_table();
                            GetFirmwareChunkRequestBuilder {
                                fbb_: _fbb,
                                start_: start,
                            }
                        }
                        #[inline]
                        pub fn finish(self) -> flatbuffers::WIPOffset<GetFirmwareChunkRequest<'a>> {
                            let o = self.fbb_.end_table(self.start_);
                            flatbuffers::WIPOffset::new(o.value())
                        }
                    }

                    impl core::fmt::Debug for GetFirmwareChunkRequest<'_> {
                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                            let mut ds = f.debug_struct("GetFirmwareChunkRequest");
                            ds.field("name", &self.name());
                            ds.field("offset", &self.offset());
                            ds.field("size_", &self.size_());
                            ds.finish()
                        }
                    }
                    pub enum GetFirmwareChunkResponseOffset {}
                    #[derive(Copy, Clone, PartialEq)]

                    pub struct GetFirmwareChunkResponse<'a> {
                        pub _tab: flatbuffers::Table<'a>,
                    }

                    impl<'a> flatbuffers::Follow<'a> for GetFirmwareChunkResponse<'a> {
                        type Inner = GetFirmwareChunkResponse<'a>;
                        #[inline]
                        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                            Self {
                                _tab: flatbuffers::Table::new(buf, loc),
                            }
                        }
                    }

                    impl<'a> GetFirmwareChunkResponse<'a> {
                        pub const VT_SIZE_: flatbuffers::VOffsetT = 4;
                        pub const VT_OFFSET: flatbuffers::VOffsetT = 6;
                        pub const VT_CHUNK: flatbuffers::VOffsetT = 8;

                        #[inline]
                        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                            GetFirmwareChunkResponse { _tab: table }
                        }
                        #[allow(unused_mut)]
                        pub fn create<
                            'bldr: 'args,
                            'args: 'mut_bldr,
                            'mut_bldr,
                            A: flatbuffers::Allocator + 'bldr,
                        >(
                            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                            args: &'args GetFirmwareChunkResponseArgs<'args>,
                        ) -> flatbuffers::WIPOffset<GetFirmwareChunkResponse<'bldr>>
                        {
                            let mut builder = GetFirmwareChunkResponseBuilder::new(_fbb);
                            if let Some(x) = args.chunk {
                                builder.add_chunk(x);
                            }
                            builder.add_offset(args.offset);
                            builder.add_size_(args.size_);
                            builder.finish()
                        }

                        #[inline]
                        pub fn size_(&self) -> u16 {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab
                                    .get::<u16>(GetFirmwareChunkResponse::VT_SIZE_, Some(0))
                                    .unwrap()
                            }
                        }
                        #[inline]
                        pub fn offset(&self) -> u16 {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab
                                    .get::<u16>(GetFirmwareChunkResponse::VT_OFFSET, Some(0))
                                    .unwrap()
                            }
                        }
                        #[inline]
                        pub fn chunk(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GetFirmwareChunkResponse::VT_CHUNK, None)
                            }
                        }
                    }

                    impl flatbuffers::Verifiable for GetFirmwareChunkResponse<'_> {
                        #[inline]
                        fn run_verifier(
                            v: &mut flatbuffers::Verifier,
                            pos: usize,
                        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                            use self::flatbuffers::Verifiable;
                            v.visit_table(pos)?
     .visit_field::<u16>("size_", Self::VT_SIZE_, false)?
     .visit_field::<u16>("offset", Self::VT_OFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("chunk", Self::VT_CHUNK, false)?
     .finish();
                            Ok(())
                        }
                    }
                    pub struct GetFirmwareChunkResponseArgs<'a> {
                        pub size_: u16,
                        pub offset: u16,
                        pub chunk: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                    }
                    impl<'a> Default for GetFirmwareChunkResponseArgs<'a> {
                        #[inline]
                        fn default() -> Self {
                            GetFirmwareChunkResponseArgs {
                                size_: 0,
                                offset: 0,
                                chunk: None,
                            }
                        }
                    }

                    pub struct GetFirmwareChunkResponseBuilder<
                        'a: 'b,
                        'b,
                        A: flatbuffers::Allocator + 'a,
                    > {
                        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                    }
                    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetFirmwareChunkResponseBuilder<'a, 'b, A> {
                        #[inline]
                        pub fn add_size_(&mut self, size_: u16) {
                            self.fbb_.push_slot::<u16>(
                                GetFirmwareChunkResponse::VT_SIZE_,
                                size_,
                                0,
                            );
                        }
                        #[inline]
                        pub fn add_offset(&mut self, offset: u16) {
                            self.fbb_.push_slot::<u16>(
                                GetFirmwareChunkResponse::VT_OFFSET,
                                offset,
                                0,
                            );
                        }
                        #[inline]
                        pub fn add_chunk(
                            &mut self,
                            chunk: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                        ) {
                            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                                GetFirmwareChunkResponse::VT_CHUNK,
                                chunk,
                            );
                        }
                        #[inline]
                        pub fn new(
                            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        ) -> GetFirmwareChunkResponseBuilder<'a, 'b, A> {
                            let start = _fbb.start_table();
                            GetFirmwareChunkResponseBuilder {
                                fbb_: _fbb,
                                start_: start,
                            }
                        }
                        #[inline]
                        pub fn finish(
                            self,
                        ) -> flatbuffers::WIPOffset<GetFirmwareChunkResponse<'a>>
                        {
                            let o = self.fbb_.end_table(self.start_);
                            flatbuffers::WIPOffset::new(o.value())
                        }
                    }

                    impl core::fmt::Debug for GetFirmwareChunkResponse<'_> {
                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                            let mut ds = f.debug_struct("GetFirmwareChunkResponse");
                            ds.field("size_", &self.size_());
                            ds.field("offset", &self.offset());
                            ds.field("chunk", &self.chunk());
                            ds.finish()
                        }
                    }
                    pub enum FirmwareMessageOffset {}
                    #[derive(Copy, Clone, PartialEq)]

                    pub struct FirmwareMessage<'a> {
                        pub _tab: flatbuffers::Table<'a>,
                    }

                    impl<'a> flatbuffers::Follow<'a> for FirmwareMessage<'a> {
                        type Inner = FirmwareMessage<'a>;
                        #[inline]
                        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                            Self {
                                _tab: flatbuffers::Table::new(buf, loc),
                            }
                        }
                    }

                    impl<'a> FirmwareMessage<'a> {
                        pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 4;
                        pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;
                        pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 8;
                        pub const VT_SESSION_TOKEN: flatbuffers::VOffsetT = 10;

                        #[inline]
                        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                            FirmwareMessage { _tab: table }
                        }
                        #[allow(unused_mut)]
                        pub fn create<
                            'bldr: 'args,
                            'args: 'mut_bldr,
                            'mut_bldr,
                            A: flatbuffers::Allocator + 'bldr,
                        >(
                            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                            args: &'args FirmwareMessageArgs<'args>,
                        ) -> flatbuffers::WIPOffset<FirmwareMessage<'bldr>>
                        {
                            let mut builder = FirmwareMessageBuilder::new(_fbb);
                            builder.add_request_id(args.request_id);
                            if let Some(x) = args.session_token {
                                builder.add_session_token(x);
                            }
                            if let Some(x) = args.payload {
                                builder.add_payload(x);
                            }
                            builder.add_payload_type(args.payload_type);
                            builder.finish()
                        }

                        #[inline]
                        pub fn payload_type(&self) -> MessagePayload {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab
                                    .get::<MessagePayload>(
                                        FirmwareMessage::VT_PAYLOAD_TYPE,
                                        Some(MessagePayload::NONE),
                                    )
                                    .unwrap()
                            }
                        }
                        #[inline]
                        pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab
                                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                                        FirmwareMessage::VT_PAYLOAD,
                                        None,
                                    )
                            }
                        }
                        #[inline]
                        pub fn request_id(&self) -> i64 {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab
                                    .get::<i64>(FirmwareMessage::VT_REQUEST_ID, Some(0))
                                    .unwrap()
                            }
                        }
                        #[inline]
                        pub fn session_token(&self) -> Option<&'a str> {
                            // Safety:
                            // Created from valid Table for this object
                            // which contains a valid value in this slot
                            unsafe {
                                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                                    FirmwareMessage::VT_SESSION_TOKEN,
                                    None,
                                )
                            }
                        }
                        #[inline]
                        #[allow(non_snake_case)]
                        pub fn payload_as_firmware_challenge_request(
                            &self,
                        ) -> Option<FirmwareChallengeRequest<'a>> {
                            if self.payload_type() == MessagePayload::FirmwareChallengeRequest {
                                self.payload().map(|t| {
                                    // Safety:
                                    // Created from a valid Table for this object
                                    // Which contains a valid union in this slot
                                    unsafe { FirmwareChallengeRequest::init_from_table(t) }
                                })
                            } else {
                                None
                            }
                        }

                        #[inline]
                        #[allow(non_snake_case)]
                        pub fn payload_as_firmware_challenge_response(
                            &self,
                        ) -> Option<FirmwareChallengeResponse<'a>> {
                            if self.payload_type() == MessagePayload::FirmwareChallengeResponse {
                                self.payload().map(|t| {
                                    // Safety:
                                    // Created from a valid Table for this object
                                    // Which contains a valid union in this slot
                                    unsafe { FirmwareChallengeResponse::init_from_table(t) }
                                })
                            } else {
                                None
                            }
                        }

                        #[inline]
                        #[allow(non_snake_case)]
                        pub fn payload_as_get_latest_firmware_request(
                            &self,
                        ) -> Option<GetLatestFirmwareRequest<'a>> {
                            if self.payload_type() == MessagePayload::GetLatestFirmwareRequest {
                                self.payload().map(|t| {
                                    // Safety:
                                    // Created from a valid Table for this object
                                    // Which contains a valid union in this slot
                                    unsafe { GetLatestFirmwareRequest::init_from_table(t) }
                                })
                            } else {
                                None
                            }
                        }

                        #[inline]
                        #[allow(non_snake_case)]
                        pub fn payload_as_get_latest_firmware_response(
                            &self,
                        ) -> Option<GetLatestFirmwareResponse<'a>> {
                            if self.payload_type() == MessagePayload::GetLatestFirmwareResponse {
                                self.payload().map(|t| {
                                    // Safety:
                                    // Created from a valid Table for this object
                                    // Which contains a valid union in this slot
                                    unsafe { GetLatestFirmwareResponse::init_from_table(t) }
                                })
                            } else {
                                None
                            }
                        }

                        #[inline]
                        #[allow(non_snake_case)]
                        pub fn payload_as_get_firmware_chunk_request(
                            &self,
                        ) -> Option<GetFirmwareChunkRequest<'a>> {
                            if self.payload_type() == MessagePayload::GetFirmwareChunkRequest {
                                self.payload().map(|t| {
                                    // Safety:
                                    // Created from a valid Table for this object
                                    // Which contains a valid union in this slot
                                    unsafe { GetFirmwareChunkRequest::init_from_table(t) }
                                })
                            } else {
                                None
                            }
                        }

                        #[inline]
                        #[allow(non_snake_case)]
                        pub fn payload_as_get_firmware_chunk_response(
                            &self,
                        ) -> Option<GetFirmwareChunkResponse<'a>> {
                            if self.payload_type() == MessagePayload::GetFirmwareChunkResponse {
                                self.payload().map(|t| {
                                    // Safety:
                                    // Created from a valid Table for this object
                                    // Which contains a valid union in this slot
                                    unsafe { GetFirmwareChunkResponse::init_from_table(t) }
                                })
                            } else {
                                None
                            }
                        }
                    }

                    impl flatbuffers::Verifiable for FirmwareMessage<'_> {
                        #[inline]
                        fn run_verifier(
                            v: &mut flatbuffers::Verifier,
                            pos: usize,
                        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                            use self::flatbuffers::Verifiable;
                            v.visit_table(pos)?
     .visit_union::<MessagePayload, _>("payload_type", Self::VT_PAYLOAD_TYPE, "payload", Self::VT_PAYLOAD, false, |key, v, pos| {
        match key {
          MessagePayload::FirmwareChallengeRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FirmwareChallengeRequest>>("MessagePayload::FirmwareChallengeRequest", pos),
          MessagePayload::FirmwareChallengeResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FirmwareChallengeResponse>>("MessagePayload::FirmwareChallengeResponse", pos),
          MessagePayload::GetLatestFirmwareRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetLatestFirmwareRequest>>("MessagePayload::GetLatestFirmwareRequest", pos),
          MessagePayload::GetLatestFirmwareResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetLatestFirmwareResponse>>("MessagePayload::GetLatestFirmwareResponse", pos),
          MessagePayload::GetFirmwareChunkRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetFirmwareChunkRequest>>("MessagePayload::GetFirmwareChunkRequest", pos),
          MessagePayload::GetFirmwareChunkResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetFirmwareChunkResponse>>("MessagePayload::GetFirmwareChunkResponse", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<i64>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("session_token", Self::VT_SESSION_TOKEN, false)?
     .finish();
                            Ok(())
                        }
                    }
                    pub struct FirmwareMessageArgs<'a> {
                        pub payload_type: MessagePayload,
                        pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
                        pub request_id: i64,
                        pub session_token: Option<flatbuffers::WIPOffset<&'a str>>,
                    }
                    impl<'a> Default for FirmwareMessageArgs<'a> {
                        #[inline]
                        fn default() -> Self {
                            FirmwareMessageArgs {
                                payload_type: MessagePayload::NONE,
                                payload: None,
                                request_id: 0,
                                session_token: None,
                            }
                        }
                    }

                    pub struct FirmwareMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                    }
                    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FirmwareMessageBuilder<'a, 'b, A> {
                        #[inline]
                        pub fn add_payload_type(&mut self, payload_type: MessagePayload) {
                            self.fbb_.push_slot::<MessagePayload>(
                                FirmwareMessage::VT_PAYLOAD_TYPE,
                                payload_type,
                                MessagePayload::NONE,
                            );
                        }
                        #[inline]
                        pub fn add_payload(
                            &mut self,
                            payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
                        ) {
                            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                                FirmwareMessage::VT_PAYLOAD,
                                payload,
                            );
                        }
                        #[inline]
                        pub fn add_request_id(&mut self, request_id: i64) {
                            self.fbb_.push_slot::<i64>(
                                FirmwareMessage::VT_REQUEST_ID,
                                request_id,
                                0,
                            );
                        }
                        #[inline]
                        pub fn add_session_token(
                            &mut self,
                            session_token: flatbuffers::WIPOffset<&'b str>,
                        ) {
                            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                                FirmwareMessage::VT_SESSION_TOKEN,
                                session_token,
                            );
                        }
                        #[inline]
                        pub fn new(
                            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        ) -> FirmwareMessageBuilder<'a, 'b, A> {
                            let start = _fbb.start_table();
                            FirmwareMessageBuilder {
                                fbb_: _fbb,
                                start_: start,
                            }
                        }
                        #[inline]
                        pub fn finish(self) -> flatbuffers::WIPOffset<FirmwareMessage<'a>> {
                            let o = self.fbb_.end_table(self.start_);
                            flatbuffers::WIPOffset::new(o.value())
                        }
                    }

                    impl core::fmt::Debug for FirmwareMessage<'_> {
                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                            let mut ds = f.debug_struct("FirmwareMessage");
                            ds.field("payload_type", &self.payload_type());
                            match self.payload_type() {
                                MessagePayload::FirmwareChallengeRequest => {
                                    if let Some(x) = self.payload_as_firmware_challenge_request() {
                                        ds.field("payload", &x)
                                    } else {
                                        ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                    }
                                }
                                MessagePayload::FirmwareChallengeResponse => {
                                    if let Some(x) = self.payload_as_firmware_challenge_response() {
                                        ds.field("payload", &x)
                                    } else {
                                        ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                    }
                                }
                                MessagePayload::GetLatestFirmwareRequest => {
                                    if let Some(x) = self.payload_as_get_latest_firmware_request() {
                                        ds.field("payload", &x)
                                    } else {
                                        ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                    }
                                }
                                MessagePayload::GetLatestFirmwareResponse => {
                                    if let Some(x) = self.payload_as_get_latest_firmware_response()
                                    {
                                        ds.field("payload", &x)
                                    } else {
                                        ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                    }
                                }
                                MessagePayload::GetFirmwareChunkRequest => {
                                    if let Some(x) = self.payload_as_get_firmware_chunk_request() {
                                        ds.field("payload", &x)
                                    } else {
                                        ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                    }
                                }
                                MessagePayload::GetFirmwareChunkResponse => {
                                    if let Some(x) = self.payload_as_get_firmware_chunk_response() {
                                        ds.field("payload", &x)
                                    } else {
                                        ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
                                    }
                                }
                                _ => {
                                    let x: Option<()> = None;
                                    ds.field("payload", &x)
                                }
                            };
                            ds.field("request_id", &self.request_id());
                            ds.field("session_token", &self.session_token());
                            ds.finish()
                        }
                    }
                    #[inline]
                    /// Verifies that a buffer of bytes contains a `FirmwareMessage`
                    /// and returns it.
                    /// Note that verification is still experimental and may not
                    /// catch every error, or be maximally performant. For the
                    /// previous, unchecked, behavior use
                    /// `root_as_firmware_message_unchecked`.
                    pub fn root_as_firmware_message(
                        buf: &[u8],
                    ) -> Result<FirmwareMessage, flatbuffers::InvalidFlatbuffer>
                    {
                        flatbuffers::root::<FirmwareMessage>(buf)
                    }
                    #[inline]
                    /// Verifies that a buffer of bytes contains a size prefixed
                    /// `FirmwareMessage` and returns it.
                    /// Note that verification is still experimental and may not
                    /// catch every error, or be maximally performant. For the
                    /// previous, unchecked, behavior use
                    /// `size_prefixed_root_as_firmware_message_unchecked`.
                    pub fn size_prefixed_root_as_firmware_message(
                        buf: &[u8],
                    ) -> Result<FirmwareMessage, flatbuffers::InvalidFlatbuffer>
                    {
                        flatbuffers::size_prefixed_root::<FirmwareMessage>(buf)
                    }
                    #[inline]
                    /// Verifies, with the given options, that a buffer of bytes
                    /// contains a `FirmwareMessage` and returns it.
                    /// Note that verification is still experimental and may not
                    /// catch every error, or be maximally performant. For the
                    /// previous, unchecked, behavior use
                    /// `root_as_firmware_message_unchecked`.
                    pub fn root_as_firmware_message_with_opts<'b, 'o>(
                        opts: &'o flatbuffers::VerifierOptions,
                        buf: &'b [u8],
                    ) -> Result<FirmwareMessage<'b>, flatbuffers::InvalidFlatbuffer>
                    {
                        flatbuffers::root_with_opts::<FirmwareMessage<'b>>(opts, buf)
                    }
                    #[inline]
                    /// Verifies, with the given verifier options, that a buffer of
                    /// bytes contains a size prefixed `FirmwareMessage` and returns
                    /// it. Note that verification is still experimental and may not
                    /// catch every error, or be maximally performant. For the
                    /// previous, unchecked, behavior use
                    /// `root_as_firmware_message_unchecked`.
                    pub fn size_prefixed_root_as_firmware_message_with_opts<'b, 'o>(
                        opts: &'o flatbuffers::VerifierOptions,
                        buf: &'b [u8],
                    ) -> Result<FirmwareMessage<'b>, flatbuffers::InvalidFlatbuffer>
                    {
                        flatbuffers::size_prefixed_root_with_opts::<FirmwareMessage<'b>>(opts, buf)
                    }
                    #[inline]
                    /// Assumes, without verification, that a buffer of bytes contains a FirmwareMessage and returns it.
                    /// # Safety
                    /// Callers must trust the given bytes do indeed contain a valid `FirmwareMessage`.
                    pub unsafe fn root_as_firmware_message_unchecked(
                        buf: &[u8],
                    ) -> FirmwareMessage {
                        flatbuffers::root_unchecked::<FirmwareMessage>(buf)
                    }
                    #[inline]
                    /// Assumes, without verification, that a buffer of bytes contains a size prefixed FirmwareMessage and returns it.
                    /// # Safety
                    /// Callers must trust the given bytes do indeed contain a valid size prefixed `FirmwareMessage`.
                    pub unsafe fn size_prefixed_root_as_firmware_message_unchecked(
                        buf: &[u8],
                    ) -> FirmwareMessage {
                        flatbuffers::size_prefixed_root_unchecked::<FirmwareMessage>(buf)
                    }
                    #[inline]
                    pub fn finish_firmware_message_buffer<
                        'a,
                        'b,
                        A: flatbuffers::Allocator + 'a,
                    >(
                        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        root: flatbuffers::WIPOffset<FirmwareMessage<'a>>,
                    ) {
                        fbb.finish(root, None);
                    }

                    #[inline]
                    pub fn finish_size_prefixed_firmware_message_buffer<
                        'a,
                        'b,
                        A: flatbuffers::Allocator + 'a,
                    >(
                        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                        root: flatbuffers::WIPOffset<FirmwareMessage<'a>>,
                    ) {
                        fbb.finish_size_prefixed(root, None);
                    }
                } // pub mod firmware
            } // pub mod message
        } // pub mod fb
    } // pub mod subjugated
} // pub mod club
